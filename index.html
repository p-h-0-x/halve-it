<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Darts Halve-It Scorer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .setup-section {
            max-width: 500px;
            margin: 0 auto 30px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .setup-section h2 {
            margin-bottom: 15px;
            color: #3282b8;
        }

        .language-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .lang-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            background: rgba(0,0,0,0.3);
            color: white;
            transition: all 0.3s ease;
        }

        .lang-btn:hover {
            background: rgba(50, 130, 184, 0.5);
        }

        .lang-btn.active {
            background: #3282b8;
            border-color: #bbe1fa;
        }

        .mode-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .mode-option:hover {
            background: rgba(0,0,0,0.3);
        }

        .mode-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .mode-label {
            font-weight: 600;
        }

        .mode-description {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 10px;
        }

        .player-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .player-input input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #e94560;
            color: white;
        }

        .btn-primary:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #00b894;
            color: white;
        }

        .btn-success:hover {
            background: #00d9a5;
        }

        .btn-danger {
            background: #d63031;
            color: white;
        }

        .btn-secondary {
            background: #636e72;
            color: white;
        }

        .btn-secondary:hover {
            background: #7d8a8f;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 14px;
        }

        .player-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .player-tag {
            background: #3282b8;
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-tag button {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            font-size: 12px;
        }

        .game-board {
            max-width: 900px;
            margin: 0 auto;
            display: none;
        }

        .current-round {
            text-align: center;
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .current-round h2 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .current-round p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .scores-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .scores-table th, .scores-table td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .scores-table th {
            background: rgba(0,0,0,0.3);
            font-weight: 600;
        }

        .scores-table tr:hover {
            background: rgba(255,255,255,0.05);
        }

        .round-name-cell {
            text-align: left !important;
            font-weight: 600;
            color: #bbe1fa;
        }

        .round-current {
            background: rgba(233, 69, 96, 0.3) !important;
        }

        .score-success {
            color: #00b894;
            font-weight: bold;
        }

        .score-fail {
            color: #ff6b6b;
        }

        .total-row {
            background: rgba(0,0,0,0.4) !important;
            font-size: 1.1em;
        }

        .total-row td {
            font-weight: bold;
            color: #f9d423;
        }

        .score-input-section {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .score-input-section h3 {
            margin-bottom: 15px;
            color: #3282b8;
        }

        .player-score-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-score-card {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .player-score-card h4 {
            margin-bottom: 10px;
            color: #bbe1fa;
        }

        .player-score-card .current-capital {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 10px;
        }

        .score-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .score-row input[type="number"] {
            flex: 1;
            max-width: 120px;
            padding: 8px;
            border: none;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .winner-section {
            display: none;
            text-align: center;
            background: linear-gradient(135deg, #f9d423, #ff4e50);
            padding: 40px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .winner-section h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .winner-section .trophy {
            font-size: 4em;
            margin-bottom: 15px;
        }

        /* ==================== TOURNAMENT STYLES ==================== */

        .tournament-toggle {
            text-align: center;
            margin-bottom: 15px;
        }

        .tournament-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .tournament-hub {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .tournament-hub.hidden {
            display: none;
        }

        .tournament-hub h2 {
            text-align: center;
            color: #e94560;
            margin-bottom: 20px;
        }

        .bracket-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 20px 0;
            min-height: 200px;
            align-items: flex-start;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            min-width: 170px;
            flex-shrink: 0;
        }

        .bracket-round-title {
            text-align: center;
            color: #3282b8;
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 10px;
            padding: 5px 10px;
            background: rgba(50, 130, 184, 0.2);
            border-radius: 8px;
        }

        .bracket-match {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #636e72;
            transition: all 0.3s ease;
        }

        .bracket-match.completed {
            border-left-color: #00b894;
        }

        .bracket-match.in-progress {
            border-left-color: #e94560;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
        }

        .bracket-match.bye {
            border-style: dashed;
            border-left-style: dashed;
            border-color: rgba(255, 255, 255, 0.15);
            opacity: 0.7;
        }

        .bracket-match-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            border-radius: 5px;
            margin: 2px 0;
            font-size: 0.9em;
        }

        .bracket-match-player.winner {
            background: rgba(0, 184, 148, 0.2);
            color: #00b894;
            font-weight: bold;
        }

        .bracket-match-player.loser {
            opacity: 0.5;
        }

        .bracket-match-vs {
            text-align: center;
            color: #636e72;
            font-size: 0.75em;
            margin: 2px 0;
        }

        .bracket-match-empty {
            background: rgba(0, 0, 0, 0.15);
            border: 2px dashed rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            text-align: center;
            color: #636e72;
            font-style: italic;
            font-size: 0.85em;
        }

        .match-picker {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .match-picker h3 {
            color: #3282b8;
            margin-bottom: 15px;
        }

        .available-players {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .match-picker-player {
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            font-size: 1em;
        }

        .match-picker-player:hover {
            border-color: #3282b8;
            background: rgba(50, 130, 184, 0.2);
        }

        .match-picker-player.selected {
            border-color: #00b894;
            background: rgba(0, 184, 148, 0.2);
            color: #00b894;
            font-weight: bold;
        }

        .tournament-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .tournament-champion-section {
            text-align: center;
            padding: 40px 20px;
        }

        .tournament-champion-section .champion-trophy {
            font-size: 5em;
            margin-bottom: 15px;
        }

        .tournament-champion-section h2 {
            color: #f9d423;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .tournament-champion-section h3 {
            color: #e94560;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .tie-resolution {
            margin-top: 15px;
        }

        .tie-resolution p {
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .tie-resolution-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tie-resolution-btn {
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #3282b8;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .tie-resolution-btn:hover {
            background: rgba(50, 130, 184, 0.3);
            border-color: #00b894;
        }

        .tournament-player-mgmt {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }

        .tournament-player-mgmt summary {
            cursor: pointer;
            color: #3282b8;
            font-weight: bold;
            font-size: 1.1em;
            padding: 5px 0;
        }

        .tournament-player-mgmt summary:hover {
            color: #00b894;
        }

        .tournament-player-add {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .tournament-player-add input {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: white;
            font-size: 1em;
        }

        .tournament-player-roster {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tournament-roster-player {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            font-size: 0.9em;
            color: #ccc;
        }

        .tournament-roster-player.eliminated {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .tournament-roster-player.withdrawn {
            opacity: 0.4;
            text-decoration: line-through;
            border-color: #e94560;
        }

        .tournament-roster-remove {
            background: none;
            border: none;
            color: #e94560;
            cursor: pointer;
            font-size: 1.1em;
            padding: 0 2px;
            line-height: 1;
        }

        .tournament-roster-remove:hover {
            color: #ff6b81;
        }

        .rules-section {
            max-width: 800px;
            margin: 30px auto;
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 15px;
        }

        .rules-section h3 {
            color: #3282b8;
            margin-bottom: 15px;
        }

        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .rule-item {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }

        .rule-item strong {
            color: #e94560;
        }

        .hidden {
            display: none !important;
        }

        .reset-game-section {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
        }

        /* Dart Input Styles */
        .dart-input-btn {
            background: rgba(50, 130, 184, 0.3);
            border: 2px solid #3282b8;
            padding: 8px 12px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .dart-input-btn:hover {
            background: rgba(50, 130, 184, 0.5);
            transform: scale(1.1);
        }

        .dart-input-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .dart-input-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dart-input-container {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .dart-input-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .dart-input-header h3 {
            color: #e94560;
            margin: 0;
        }

        .close-dart-input {
            background: #d63031;
            border: none;
            color: white;
            font-size: 24px;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dart-input-current {
            text-align: center;
            margin-bottom: 20px;
        }

        .dart-input-current h4 {
            color: #3282b8;
            margin-bottom: 10px;
        }

        .darts-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .dart-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 60px;
            text-align: center;
            color: #00b894;
            font-weight: bold;
        }

        .dart-display.empty {
            color: #636e72;
        }

        .dart-total {
            font-size: 1.3em;
            color: #f9d423;
            margin-top: 10px;
        }

        .modifier-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .modifier-btn {
            padding: 12px 20px;
            border: 2px solid #3282b8;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            transition: all 0.3s ease;
        }

        .modifier-btn:hover {
            background: rgba(50, 130, 184, 0.5);
        }

        .modifier-btn.active {
            background: #3282b8;
            border-color: #bbe1fa;
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .number-btn {
            padding: 15px 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            transition: all 0.3s ease;
        }

        .number-btn:hover {
            background: rgba(233, 69, 96, 0.5);
            border-color: #e94560;
        }

        .number-btn.bull {
            grid-column: span 2;
            background: rgba(233, 69, 96, 0.3);
        }

        .dart-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Yahtzee Mode Styles */
        .hide-scores-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .hide-scores-btn:hover {
            background: rgba(0,0,0,0.7);
        }

        .score-hidden {
            filter: blur(8px);
            user-select: none;
        }

        .current-player-banner {
            text-align: center;
            background: linear-gradient(135deg, #3282b8, #0f4c75);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .current-player-banner h3 {
            font-size: 1.5em;
            margin: 0;
        }

        .contract-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .contract-btn {
            padding: 12px 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.3);
            color: white;
        }

        .contract-btn:hover:not(:disabled) {
            background: rgba(50, 130, 184, 0.5);
            border-color: #3282b8;
        }

        .contract-btn.selected {
            background: #3282b8;
            border-color: #bbe1fa;
        }

        .contract-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        .contract-btn.scratched {
            background: rgba(214, 48, 49, 0.3);
        }

        .contract-btn.scratch-mode {
            background: rgba(214, 48, 49, 0.5);
            border-color: #d63031;
        }

        .scratch-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .scratch-section h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        .scratch-mode-toggle {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .toggle-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.3);
            color: white;
        }

        .toggle-btn.active {
            background: #3282b8;
            border-color: #bbe1fa;
        }

        .toggle-btn.scratch-active {
            background: #d63031;
            border-color: #ff6b6b;
        }

        .yahtzee-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .cell-scratched {
            color: #636e72;
            text-decoration: line-through;
        }

        .cell-filled {
            color: #00b894;
            font-weight: bold;
        }

        /* Killer Mode Styles */
        .killer-banner {
            text-align: center;
            background: linear-gradient(135deg, #6c5ce7, #a855f7);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .killer-banner h3 {
            font-size: 1.5em;
            margin: 0;
        }

        .killer-number-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            vertical-align: middle;
        }

        .killer-banner .killer-badge-banner {
            display: inline-block;
            background: #d63031;
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.7em;
            margin-left: 8px;
            vertical-align: middle;
        }

        .killer-dartboard-section {
            max-width: 450px;
            margin: 0 auto 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
        }

        .killer-darts-display {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .killer-dart-slot {
            width: 70px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: #636e72;
        }

        .killer-dart-slot.filled {
            color: #00b894;
            border-color: #00b894;
        }

        .killer-modifier-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 12px;
        }

        .killer-modifier-btn {
            padding: 8px 18px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            color: white;
            transition: all 0.2s ease;
        }

        .killer-modifier-btn.active {
            background: #6c5ce7;
            border-color: #a855f7;
        }

        .killer-number-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .killer-number-selection-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .killer-player-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .killer-player-row-label {
            font-size: 0.85em;
            font-weight: bold;
            color: #bbe1fa;
            min-width: 70px;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .killer-player-row-label.is-self {
            color: #6c5ce7;
        }

        .killer-player-row-buttons {
            display: flex;
            gap: 6px;
            flex: 1;
        }

        .killer-num-btn {
            padding: 12px 0;
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            color: white;
            transition: all 0.2s ease;
            flex: 1;
        }

        .killer-num-btn.own-number {
            border-color: #6c5ce7;
            background: rgba(108, 92, 231, 0.25);
        }

        .killer-num-btn.adj-number {
            border-color: rgba(255,255,255,0.25);
        }

        .killer-num-btn:hover {
            background: rgba(108, 92, 231, 0.5);
            border-color: #6c5ce7;
        }

        .killer-num-btn:active {
            transform: scale(0.95);
        }

        .killer-num-btn.taken {
            opacity: 0.3;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        .killer-miss-row {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .killer-num-btn.miss-btn {
            flex: 1;
        }

        .killer-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .killer-scoreboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .killer-player-card {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .killer-player-card.current-turn {
            border-color: #6c5ce7;
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.4);
        }

        .killer-player-card.is-killer {
            border-color: #d63031;
            background: rgba(214, 48, 49, 0.15);
        }

        .killer-player-card.is-killer.current-turn {
            border-color: #6c5ce7;
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.4), 0 0 30px rgba(214, 48, 49, 0.3);
            background: rgba(214, 48, 49, 0.15);
        }

        .killer-player-card.eliminated {
            opacity: 0.4;
            border-color: rgba(255,255,255,0.05);
        }

        .killer-player-card .player-name {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 4px;
        }

        .killer-player-card.eliminated .player-name {
            text-decoration: line-through;
        }

        .killer-player-card .player-number {
            font-size: 0.85em;
            color: #bbe1fa;
            margin-bottom: 6px;
        }

        .killer-lives-bar {
            width: 100%;
            height: 14px;
            background: rgba(255,255,255,0.1);
            border-radius: 7px;
            overflow: hidden;
            margin: 6px 0 4px;
        }

        .killer-lives-fill {
            height: 100%;
            border-radius: 7px;
            transition: width 0.4s ease, background 0.4s ease;
            background: #00b894;
        }

        .killer-lives-fill.killer-level {
            background: #d63031;
        }

        .killer-lives-count {
            font-size: 0.85em;
            color: #b2bec3;
        }

        .killer-badge {
            display: inline-block;
            background: #d63031;
            color: white;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 4px;
        }

        .killer-eliminated-badge {
            display: inline-block;
            background: #636e72;
            color: white;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 4px;
        }

        .killer-turn-summary {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px auto;
            max-width: 450px;
            text-align: center;
        }

        .killer-life-change {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 8px;
            margin: 3px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .killer-life-change.positive {
            background: rgba(0, 184, 148, 0.3);
            color: #00b894;
        }

        .killer-life-change.negative {
            background: rgba(214, 48, 49, 0.3);
            color: #ff6b6b;
        }

        /* Clock Mode */
        .clock-banner {
            text-align: center;
            background: linear-gradient(135deg, #0984e3, #00b894);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .clock-banner h3 {
            font-size: 1.5em;
            margin: 0;
        }

        .clock-banner p {
            margin: 5px 0 0;
            opacity: 0.9;
        }

        .clock-dartboard-section {
            max-width: 450px;
            margin: 0 auto 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
        }

        .clock-darts-display {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .clock-dart-slot {
            width: 70px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: #636e72;
        }

        .clock-dart-slot.filled {
            color: #00b894;
            border-color: #00b894;
        }

        .clock-modifier-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 12px;
        }

        .clock-modifier-btn {
            padding: 8px 18px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            color: white;
            transition: all 0.2s ease;
        }

        .clock-modifier-btn.active {
            background: #0984e3;
            border-color: #00b894;
        }

        .clock-number-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .clock-num-btn {
            padding: 14px 0;
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            color: white;
            transition: all 0.2s ease;
        }

        .clock-num-btn:hover {
            background: rgba(9, 132, 227, 0.5);
            border-color: #0984e3;
        }

        .clock-num-btn:active {
            transform: scale(0.95);
        }

        .clock-num-btn.target {
            border-color: #00b894;
            background: rgba(0, 184, 148, 0.25);
        }

        .clock-num-btn.miss-btn {
            grid-column: span 5;
        }

        .clock-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .clock-scoreboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .clock-player-card {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .clock-player-card.current-turn {
            border-color: #0984e3;
            box-shadow: 0 0 15px rgba(9, 132, 227, 0.4);
        }

        .clock-player-card.finished {
            opacity: 0.4;
            border-color: rgba(255,255,255,0.05);
        }

        .clock-player-card .player-name {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 4px;
        }

        .clock-player-card.finished .player-name {
            text-decoration: line-through;
        }

        .clock-player-card .player-target {
            font-size: 0.85em;
            color: #bbe1fa;
            margin-bottom: 6px;
        }

        .clock-progress-bar {
            width: 100%;
            height: 14px;
            background: rgba(255,255,255,0.1);
            border-radius: 7px;
            overflow: hidden;
            margin: 6px 0 4px;
        }

        .clock-progress-fill {
            height: 100%;
            border-radius: 7px;
            transition: width 0.4s ease;
            background: linear-gradient(90deg, #0984e3, #00b894);
        }

        .clock-progress-text {
            font-size: 0.85em;
            color: #b2bec3;
        }

        .clock-finished-badge {
            display: inline-block;
            background: #00b894;
            color: white;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 4px;
        }

        .clock-extra-turn {
            display: inline-block;
            background: rgba(249, 212, 35, 0.3);
            color: #f9d423;
            padding: 6px 16px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            margin-top: 10px;
            animation: extraTurnPulse 1s ease-in-out 3;
        }

        @keyframes extraTurnPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        @media (max-width: 600px) {
            .scores-table {
                font-size: 0.85em;
            }

            .scores-table th, .scores-table td {
                padding: 8px 5px;
            }

            .contract-selector {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }

            .contract-btn {
                padding: 8px 5px;
                font-size: 12px;
            }

            .score-input-section {
                padding: 15px;
            }

            .yahtzee-actions {
                flex-direction: column;
            }

            .yahtzee-actions button {
                width: 100%;
            }

            .killer-scoreboard {
                grid-template-columns: repeat(2, 1fr);
            }

            .killer-player-row-label {
                min-width: 55px;
                font-size: 0.75em;
            }

            .killer-number-selection-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .killer-dartboard-section {
                padding: 15px;
            }

            .clock-scoreboard {
                grid-template-columns: repeat(2, 1fr);
            }

            .clock-dartboard-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <h1>üéØ Darts Halve-It</h1>

    <!-- Setup Section -->
    <div class="setup-section" id="setupSection">
        <!-- Language Selector -->
        <div class="language-selector">
            <button class="lang-btn active" onclick="setLanguage('en')">üá¨üáß English</button>
            <button class="lang-btn" onclick="setLanguage('fr')">üá´üá∑ Fran√ßais</button>
            <button class="lang-btn" onclick="setLanguage('es')">üá™üá∏ Espa√±ol</button>
        </div>

        <!-- Tournament Toggle -->
        <div class="tournament-toggle">
            <label class="mode-option" style="justify-content: center;">
                <input type="checkbox" id="tournamentCheckbox" onchange="toggleTournamentMode()">
                <span class="mode-label" data-i18n="tournament">Tournament</span>
            </label>
        </div>

        <h2 data-i18n="gameMode">Game Mode</h2>
        <div class="mode-selector">
            <label class="mode-option">
                <input type="radio" name="gameMode" value="classic" checked onchange="updateModeDescription()">
                <span class="mode-label" data-i18n="classic">Classic</span>
            </label>
            <label class="mode-option">
                <input type="radio" name="gameMode" value="yahtzee" onchange="updateModeDescription()">
                <span class="mode-label" data-i18n="freeChoice">Yahtzee Style</span>
            </label>
            <label class="mode-option">
                <input type="radio" name="gameMode" value="killer" onchange="updateModeDescription()">
                <span class="mode-label" data-i18n="killer">Killer</span>
            </label>
            <label class="mode-option">
                <input type="radio" name="gameMode" value="clock" onchange="updateModeDescription()">
                <span class="mode-label" data-i18n="clock">Clock</span>
            </label>
        </div>
        <p class="mode-description" id="modeDescription" data-i18n="classicDesc">Play contracts in order. Hit the target to add score, miss to halve your capital.</p>
        
        <h2 style="margin-top: 20px;" data-i18n="addPlayers">Add Players</h2>
        <div class="player-input">
            <input type="text" id="playerNameInput" data-i18n-placeholder="enterPlayerName" placeholder="Enter player name" onkeypress="if(event.key==='Enter')addPlayer()">
            <button class="btn-primary" onclick="addPlayer()" data-i18n="addPlayer">Add Player</button>
        </div>
        <div class="player-list" id="playerList"></div>
        <br>
        <button class="btn-success" onclick="handleStartClick()" id="startBtn" style="display:none;" data-i18n="startGame">Start Game</button>
    </div>

    <!-- Tournament Hub -->
    <div class="tournament-hub hidden" id="tournamentHub">
        <h2 data-i18n="tournamentBracket">Tournament Bracket</h2>

        <!-- Bracket Visualization -->
        <div class="bracket-container" id="bracketContainer"></div>

        <!-- Player Management (add/remove during tournament) -->
        <details class="tournament-player-mgmt" id="tournamentPlayerMgmt">
            <summary data-i18n="managePlayers">Manage Players</summary>
            <div class="tournament-player-add">
                <input type="text" id="tournamentAddPlayerInput" data-i18n-placeholder="addPlayerName" placeholder="New player name" maxlength="20" onkeypress="if(event.key==='Enter')addTournamentPlayer()">
                <button class="btn-success" onclick="addTournamentPlayer()" data-i18n="addPlayer">Add Player</button>
            </div>
            <div class="tournament-player-roster" id="tournamentPlayerRoster"></div>
        </details>

        <!-- Player Picker for next match -->
        <div class="match-picker" id="matchPicker">
            <h3 data-i18n="selectMatchPlayers">Select players for next match</h3>
            <div class="available-players" id="availablePlayers"></div>
            <button class="btn-success" id="startMatchBtn" onclick="startTournamentMatch()" data-i18n="startMatch" disabled>Start Match</button>
        </div>

        <!-- Champion celebration (shown when tournament ends) -->
        <div class="tournament-champion-section hidden" id="tournamentChampionSection">
            <div class="champion-trophy">üèÜüèÜüèÜ</div>
            <h2 data-i18n="tournamentComplete">Tournament Complete!</h2>
            <h3 id="championName"></h3>
        </div>

        <!-- Tournament actions -->
        <div class="tournament-actions">
            <button class="btn-primary hidden" onclick="newTournament()" id="newTournamentBtn" data-i18n="newTournament">New Tournament</button>
            <button class="btn-danger" onclick="exitTournament()" data-i18n="exitTournament">Exit Tournament</button>
        </div>
    </div>

    <!-- Game Board -->
    <div class="game-board" id="gameBoard">
        <!-- Hide Scores Button (Yahtzee mode only) -->
        <button class="hide-scores-btn hidden" id="hideScoresBtn" onclick="toggleScoreVisibility()">üëÅÔ∏è</button>

        <!-- Classic Mode: Current Round Display -->
        <div class="current-round" id="classicRoundDisplay">
            <h2 id="currentRoundName">Capital</h2>
            <p id="currentRoundDesc">First 3 darts - establish your starting score</p>
        </div>

        <!-- Yahtzee Mode: Current Player Display -->
        <div class="current-player-banner hidden" id="yahtzeePlayerDisplay">
            <h3 id="currentPlayerName">Player 1's Turn</h3>
            <p data-i18n="chooseContract">Choose a contract to fill or scratch</p>
        </div>

        <!-- Classic Mode: Score Input -->
        <div class="score-input-section" id="classicInputSection">
            <h3 data-i18n="enterScores">Enter Scores for Current Round</h3>
            <div class="player-score-inputs" id="scoreInputs"></div>
            <div class="action-buttons">
                <button class="btn-secondary" onclick="previousRound()" id="prevBtn" style="display:none;" data-i18n="previousRound">‚Üê Previous Round</button>
                <button class="btn-success" onclick="submitRound()" data-i18n="submitRound">Submit Round</button>
            </div>
        </div>

        <!-- Yahtzee Mode: Score Input -->
        <div class="score-input-section hidden" id="yahtzeeInputSection">
            <h3 data-i18n="enterYourScore">Enter Your Darts</h3>
            <div class="player-score-card" style="max-width: 400px; margin: 0 auto 20px;">
                <div class="score-row" style="flex-direction: column; align-items: stretch;">
                    <div id="yahtzeeDartsDisplay" style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px; text-align: center; min-height: 40px;">
                        <span style="color: #636e72;">No darts entered</span>
                    </div>
                    <button class="dart-input-btn" onclick="openDartInputYahtzee()" title="Enter darts" style="width: 100%;">üéØ <span data-i18n="enterDarts">Enter Your Darts</span></button>
                </div>
            </div>

            <div class="scratch-mode-toggle">
                <button class="toggle-btn active" id="fillModeBtn" onclick="toggleScratchMode(false)">
                    <span data-i18n="fillMode">Fill Contract</span>
                </button>
                <button class="toggle-btn" id="scratchModeBtn" onclick="toggleScratchMode(true)">
                    <span data-i18n="scratchMode">Scratch Contract</span>
                </button>
            </div>

            <h4 style="color: #3282b8; margin-bottom: 10px;" id="contractActionLabel" data-i18n="selectContract">Select Contract:</h4>
            <div class="contract-selector" id="contractSelector"></div>

            <div class="yahtzee-actions">
                <button class="btn-secondary" onclick="previousYahtzeeTurn()" id="yahtzeePrevBtn" style="display:none;" data-i18n="previousTurn">‚Üê Previous Turn</button>
                <button class="btn-success" onclick="submitYahtzeeChoice()" data-i18n="confirmChoice">Confirm Choice</button>
            </div>
        </div>

        <!-- Killer Mode: Banner -->
        <div class="killer-banner hidden" id="killerBanner">
            <h3 id="killerBannerText">Choose your number</h3>
            <p id="killerBannerSub"></p>
        </div>

        <!-- Killer Mode: Scoreboard -->
        <div class="killer-scoreboard hidden" id="killerScoreboard"></div>

        <!-- Killer Mode: Dartboard + Input -->
        <div class="killer-dartboard-section hidden" id="killerDartboardSection">
            <div class="killer-darts-display" id="killerDartsDisplay">
                <div class="killer-dart-slot" id="killerDart1">-</div>
                <div class="killer-dart-slot" id="killerDart2">-</div>
                <div class="killer-dart-slot" id="killerDart3">-</div>
            </div>

            <div class="killer-modifier-buttons" id="killerModifiers">
                <button class="killer-modifier-btn active" id="killerSingleBtn" onclick="setKillerModifier('single')">Single</button>
                <button class="killer-modifier-btn" id="killerDoubleBtn" onclick="setKillerModifier('double')">Double</button>
                <button class="killer-modifier-btn" id="killerTripleBtn" onclick="setKillerModifier('triple')">Triple</button>
            </div>

            <div class="killer-number-grid" id="killerNumberGrid"></div>

            <div class="killer-actions" id="killerActions">
                <button class="btn-secondary" onclick="clearLastKillerDart()">‚Üê <span data-i18n="undo">Undo</span></button>
                <button class="btn-secondary" onclick="clearAllKillerDarts()"><span data-i18n="clear">Clear</span></button>
                <button class="btn-success" onclick="submitKillerTurn()" id="killerConfirmBtn">‚úì <span data-i18n="confirm">Confirm</span></button>
            </div>
        </div>

        <!-- Killer Mode: Turn Summary -->
        <div class="killer-turn-summary hidden" id="killerTurnSummary"></div>

        <!-- Killer Mode: Previous Turn -->
        <div class="killer-actions hidden" id="killerPrevSection">
            <button class="btn-secondary" onclick="previousKillerTurn()" id="killerPrevBtn" style="display:none;" data-i18n="previousTurn">‚Üê Previous Turn</button>
        </div>

        <!-- Clock Mode: Banner -->
        <div class="clock-banner hidden" id="clockBanner">
            <h3 id="clockBannerText">Player's Turn</h3>
            <p id="clockBannerSub"></p>
            <div class="clock-extra-turn hidden" id="clockExtraTurnBadge"></div>
        </div>

        <!-- Clock Mode: Scoreboard -->
        <div class="clock-scoreboard hidden" id="clockScoreboard"></div>

        <!-- Clock Mode: Dart Input -->
        <div class="clock-dartboard-section hidden" id="clockDartboardSection">
            <div class="clock-darts-display" id="clockDartsDisplay">
                <div class="clock-dart-slot" id="clockDart1">-</div>
                <div class="clock-dart-slot" id="clockDart2">-</div>
                <div class="clock-dart-slot" id="clockDart3">-</div>
            </div>

            <div class="clock-modifier-buttons" id="clockModifiers">
                <button class="clock-modifier-btn active" id="clockSingleBtn" onclick="setClockModifier('single')">Single</button>
                <button class="clock-modifier-btn" id="clockDoubleBtn" onclick="setClockModifier('double')">Double</button>
                <button class="clock-modifier-btn" id="clockTripleBtn" onclick="setClockModifier('triple')">Triple</button>
            </div>

            <div class="clock-number-grid" id="clockNumberGrid"></div>

            <div class="clock-actions" id="clockActions">
                <button class="btn-secondary" onclick="clearLastClockDart()">‚Üê <span data-i18n="undo">Undo</span></button>
                <button class="btn-secondary" onclick="clearAllClockDarts()"><span data-i18n="clear">Clear</span></button>
                <button class="btn-success" onclick="submitClockTurn()" id="clockConfirmBtn">‚úì <span data-i18n="confirm">Confirm</span></button>
            </div>
        </div>

        <!-- Clock Mode: Previous Turn -->
        <div class="clock-actions hidden" id="clockPrevSection">
            <button class="btn-secondary" onclick="previousClockTurn()" id="clockPrevBtn" style="display:none;" data-i18n="previousTurn">‚Üê Previous Turn</button>
        </div>

        <table class="scores-table">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
        </table>

        <!-- Reset Game Button Section -->
        <div class="reset-game-section">
            <button class="btn-danger" onclick="resetGame()" data-i18n="resetGame">Reset Game</button>
        </div>

        <div class="winner-section" id="winnerSection">
            <div class="trophy">üèÜ</div>
            <h2 id="winnerName">Winner!</h2>
            <p id="winnerScore"></p>
            <br>
            <button class="btn-secondary" onclick="editLastRound()" id="editScoresBtn" data-i18n="editScores">‚Üê Edit Scores</button>
            <button class="btn-primary" onclick="resetGame()" id="playAgainBtn" data-i18n="playAgain">Play Again</button>
            <button class="btn-primary hidden" onclick="returnToTournament()" id="backToTournamentBtn" data-i18n="backToTournament">Back to Tournament</button>
            <!-- Tie Resolution UI (tournament mode) -->
            <div class="tie-resolution hidden" id="tieResolutionUI">
                <p data-i18n="tieResolution">Tie! Select the advancing player:</p>
                <div class="tie-resolution-buttons" id="tiePlayerButtons"></div>
            </div>
        </div>
    </div>

    <!-- Dart Input Modal -->
    <div class="dart-input-modal" id="dartInputModal">
        <div class="dart-input-container">
            <div class="dart-input-header">
                <h3>üéØ <span data-i18n="enterDarts">Enter Your Darts</span></h3>
                <button class="close-dart-input" onclick="closeDartInput()">√ó</button>
            </div>

            <div class="dart-input-current">
                <h4 data-i18n="dartsThrown">Darts Thrown:</h4>
                <div class="darts-display">
                    <div class="dart-display empty" id="dart1Display">-</div>
                    <div class="dart-display empty" id="dart2Display">-</div>
                    <div class="dart-display empty" id="dart3Display">-</div>
                </div>
                <div class="dart-total">
                    <span data-i18n="total">Total</span>: <span id="dartTotalDisplay">0</span>
                </div>
            </div>

            <div class="modifier-buttons">
                <button class="modifier-btn active" id="singleBtn" onclick="setModifier('single')">Single</button>
                <button class="modifier-btn" id="doubleBtn" onclick="setModifier('double')">Double</button>
                <button class="modifier-btn" id="tripleBtn" onclick="setModifier('triple')">Triple</button>
            </div>

            <div class="number-grid">
                <button class="number-btn" onclick="addDart(1)">1</button>
                <button class="number-btn" onclick="addDart(2)">2</button>
                <button class="number-btn" onclick="addDart(3)">3</button>
                <button class="number-btn" onclick="addDart(4)">4</button>
                <button class="number-btn" onclick="addDart(5)">5</button>
                <button class="number-btn" onclick="addDart(6)">6</button>
                <button class="number-btn" onclick="addDart(7)">7</button>
                <button class="number-btn" onclick="addDart(8)">8</button>
                <button class="number-btn" onclick="addDart(9)">9</button>
                <button class="number-btn" onclick="addDart(10)">10</button>
                <button class="number-btn" onclick="addDart(11)">11</button>
                <button class="number-btn" onclick="addDart(12)">12</button>
                <button class="number-btn" onclick="addDart(13)">13</button>
                <button class="number-btn" onclick="addDart(14)">14</button>
                <button class="number-btn" onclick="addDart(15)">15</button>
                <button class="number-btn" onclick="addDart(16)">16</button>
                <button class="number-btn" onclick="addDart(17)">17</button>
                <button class="number-btn" onclick="addDart(18)">18</button>
                <button class="number-btn" onclick="addDart(19)">19</button>
                <button class="number-btn" onclick="addDart(20)">20</button>
                <button class="number-btn bull" onclick="addDart(25)">BULL (25)</button>
                <button class="number-btn" onclick="addDart(0)"><span data-i18n="miss">Miss</span></button>
            </div>

            <div class="dart-actions">
                <button class="btn-secondary" onclick="clearLastDart()">‚Üê <span data-i18n="undo">Undo</span></button>
                <button class="btn-secondary" onclick="clearAllDarts()"><span data-i18n="clear">Clear</span></button>
                <button class="btn-success" onclick="confirmDarts()">‚úì <span data-i18n="confirm">Confirm</span></button>
            </div>
        </div>
    </div>

    <!-- Rules Section -->
    <div class="rules-section">
        <h3 data-i18n="gameRules">üìã Game Rules</h3>
        <p style="margin-bottom: 15px;" data-i18n="rulesClassic"><strong>Classic:</strong> Hit the contract target to add your score to your capital. Miss it and your capital is halved!</p>
        <p style="margin-bottom: 15px;" data-i18n="rulesFreeChoice"><strong>Yahtzee Style:</strong> Choose where to register your score each turn. Scratch contracts you can't fill (score 0).</p>
        <p style="margin-bottom: 15px;" data-i18n="rulesKiller"><strong>Killer:</strong> Pick a number, gain lives by hitting it (+3) or adjacent segments (+1). At 9 lives become a Killer and attack others. Doubles x2, Triples x3. Eliminated at -1 life. Last one standing wins!</p>
        <p style="margin-bottom: 15px;" data-i18n="rulesClock"><strong>Clock:</strong> Hit 1 through 10 in order, then finish with Bull. Doubles advance 2, Triples advance 3. If your last dart hits the target, you get an extra turn! First to finish wins. After 10 turns each, the player furthest ahead wins (ties possible).</p>
        <div class="rules-grid" id="rulesGrid">
            <!-- Rules will be populated by JavaScript -->
        </div>
    </div>

    <script src="src/contracts.js"></script>
    <script src="src/clock.js"></script>
    <script>
        // ==================== TRANSLATIONS ====================
        const translations = {
            en: {
                // Setup
                gameMode: "Game Mode",
                classic: "Classic",
                freeChoice: "Yahtzee Style",
                killer: "Killer",
                clock: "Clock",
                classicDesc: "Play contracts in order. Hit the target to add score, miss to halve your capital.",
                freeChoiceDesc: "Choose where to register your score. Fill or scratch contracts freely.",
                killerDesc: "Pick a number, gain lives, become a Killer, and eliminate your opponents!",
                clockDesc: "Hit 1 through 10 in order, then finish with Bull. Doubles and triples advance extra! Last dart on target = extra turn.",
                addPlayers: "Add Players",
                enterPlayerName: "Enter player name",
                addPlayer: "Add Player",
                startGame: "Start Game",
                
                // Game
                enterScores: "Enter Scores for Current Round",
                enterYourScore: "Enter Your Score",
                score: "Score:",
                currentCapital: "Current capital:",
                startingRound: "Starting round",
                previousRound: "‚Üê Previous Round",
                previousTurn: "‚Üê Previous Turn",
                submitRound: "Submit Round",
                confirmChoice: "Confirm Choice",
                resetGame: "Reset Game",
                chooseContract: "Choose a contract to fill or scratch",
                selectContractFill: "Select Contract to Fill:",
                scratchContract: "Or Scratch a Contract (score 0):",
                selectContract: "Select Contract:",
                fillMode: "Fill Contract",
                scratchMode: "Scratch Contract",
                playerTurn: "'s Turn",
                
                // Table
                round: "Round",
                contract: "Contract",
                total: "TOTAL",
                
                // Winner
                itsATie: "It's a tie!",
                tiedWith: "tied with",
                points: "points",
                wins: "Wins!",
                finalScore: "Final Score:",
                editScores: "‚Üê Edit Scores",
                playAgain: "Play Again",
                
                // Rules
                gameRules: "üìã Game Rules",
                rulesClassic: "<strong>Classic:</strong> Hit the contract target to add your score to your capital. Miss it and your capital is halved!",
                rulesFreeChoice: "<strong>Yahtzee Style:</strong> Choose where to register your score each turn. Scratch contracts you can't fill (score 0).",
                rulesKiller: "<strong>Killer:</strong> Pick a number, gain lives by hitting it (+3) or adjacent segments (+1). At 9 lives become a Killer and attack others. Doubles x2, Triples x3. Eliminated at -1 life. Last one standing wins!",
                rulesClock: "<strong>Clock:</strong> Hit 1 through 10 in order, then finish with Bull. Doubles advance 2, Triples advance 3. If your last dart hits the target, you get an extra turn! First to finish wins. After 10 turns each, the player furthest ahead wins (ties possible).",

                // Alert
                selectContractAlert: "Please select a contract to fill or scratch.",
                invalidScore: "Invalid score for this contract!",
                invalidScoreDetail: "For {contract}, score must be {rule}.",

                // Dart Input
                enterDarts: "Enter Your Darts",
                dartsThrown: "Darts Thrown:",
                miss: "Miss",
                undo: "Undo",
                clear: "Clear",
                confirm: "Confirm",

                // Killer
                chooseYourNumber: "choose your number!",
                selectNumberPrompt: "Tap a segment on the dartboard",
                lives: "lives",
                killerLabel: "KILLER",
                eliminatedLabel: "OUT",
                numberTaken: "This number is already taken!",
                enterYourDartsKiller: "Throw your 3 darts",
                noNumberYet: "?",
                turnSummaryTitle: "Turn Summary",

                // Clock
                clockTarget: "Target:",
                clockFinished: "FINISHED",
                clockExtraTurn: "Last dart hit! Extra turn!",
                clockThrowDarts: "Throw your 3 darts",
                clockBull: "Bull",
                clockTurn: "Turn",

                // Tournament
                tournament: "Tournament",
                tournamentDesc: "Single elimination tournament. Pick a game type, register players, and compete!",
                startTournament: "Start Tournament",
                tournamentBracket: "Tournament Bracket",
                selectMatchPlayers: "Select players for next match",
                startMatch: "Start Match",
                backToTournament: "Back to Tournament",
                exitTournament: "Exit Tournament",
                roundN: "Round",
                semiFinals: "Semi-Finals",
                quarterFinals: "Quarter-Finals",
                final: "Final",
                tournamentChampion: "Tournament Champion!",
                tournamentComplete: "Tournament Complete!",
                tieResolution: "Tie! Select the advancing player:",
                newTournament: "New Tournament",
                minPlayersTourn: "Add at least 3 players for a tournament",
                bye: "Bye",
                matchVs: "vs",
                tournamentRegistrants: "Tournament Registrants",
                matchScore: "Score",
                managePlayers: "Manage Players",
                addPlayer: "Add Player",
                addPlayerName: "New player name",
                removePlayer: "Remove",
                withdrawn: "withdrawn",
                playerAlreadyExists: "This player is already in the tournament.",
                cannotRemoveInMatch: "Cannot remove a player who is in an active match.",

                // Contracts
                contracts: {
                    capital: { name: "Capital", desc: "First 3 darts - establish your starting score" },
                    "20": { name: "20", desc: "Hit the 20 segment" },
                    side: { name: "Side", desc: "Hit 3 adjacent segments (e.g., 5-20-1). Bullseye touches all." },
                    "19": { name: "19", desc: "Hit the 19 segment" },
                    "3row": { name: "3 in a Row", desc: "Hit 3 consecutive numbers (e.g., 14-15-16)" },
                    "18": { name: "18", desc: "Hit the 18 segment" },
                    color: { name: "Color", desc: "Hit 3 different colors (black, white, green, red)" },
                    "17": { name: "17", desc: "Hit the 17 segment" },
                    double: { name: "Double", desc: "Hit any double" },
                    "16": { name: "16", desc: "Hit the 16 segment" },
                    triple: { name: "Triple", desc: "Hit any triple" },
                    "15": { name: "15", desc: "Hit the 15 segment" },
                    "57": { name: "57", desc: "Score exactly 57 with 3 darts" },
                    "14": { name: "14", desc: "Hit the 14 segment" },
                    bull: { name: "Bull", desc: "Hit the bullseye (single 25 or double 50)" }
                }
            },
            fr: {
                // Setup
                gameMode: "Mode de Jeu",
                classic: "Classique",
                freeChoice: "Yahtzee Style",
                killer: "Killer",
                clock: "Clock",
                classicDesc: "Jouez les contrats dans l'ordre. R√©ussissez pour ajouter le score, ratez pour diviser votre capital par deux.",
                freeChoiceDesc: "Choisissez o√π enregistrer votre score. Remplissez ou barrez les contrats librement.",
                killerDesc: "Choisissez un num√©ro, gagnez des vies, devenez un Killer et √©liminez vos adversaires !",
                clockDesc: "Touchez 1 √† 10 dans l'ordre, puis finissez avec le Bull. Les doubles et triples avancent plus ! Derni√®re fl√©chette sur la cible = tour suppl√©mentaire.",
                addPlayers: "Ajouter des Joueurs",
                enterPlayerName: "Nom du joueur",
                addPlayer: "Ajouter",
                startGame: "Commencer",
                
                // Game
                enterScores: "Entrez les Scores du Tour",
                enterYourScore: "Entrez Votre Score",
                score: "Score :",
                currentCapital: "Capital actuel :",
                startingRound: "Tour de d√©part",
                previousRound: "‚Üê Tour Pr√©c√©dent",
                previousTurn: "‚Üê Tour Pr√©c√©dent",
                submitRound: "Valider",
                confirmChoice: "Confirmer",
                resetGame: "Recommencer",
                chooseContract: "Choisissez un contrat √† remplir ou barrer",
                selectContractFill: "S√©lectionnez un Contrat √† Remplir :",
                scratchContract: "Ou Barrez un Contrat (score 0) :",
                selectContract: "S√©lectionnez un Contrat :",
                fillMode: "Remplir Contrat",
                scratchMode: "Barrer Contrat",
                playerTurn: " - √Ä votre tour",
                
                // Table
                round: "Tour",
                contract: "Contrat",
                total: "TOTAL",
                
                // Winner
                itsATie: "√âgalit√© !",
                tiedWith: "√† √©galit√© avec",
                points: "points",
                wins: "Gagne !",
                finalScore: "Score Final :",
                editScores: "‚Üê Modifier",
                playAgain: "Rejouer",
                
                // Rules
                gameRules: "üìã R√®gles du Jeu",
                rulesClassic: "<strong>Classique :</strong> R√©ussissez le contrat pour ajouter votre score au capital. Ratez et votre capital est divis√© par deux !",
                rulesFreeChoice: "<strong>Yahtzee Style :</strong> Choisissez o√π enregistrer votre score √† chaque tour. Barrez les contrats impossibles (score 0).",
                rulesKiller: "<strong>Killer :</strong> Choisissez un num√©ro, gagnez des vies en le touchant (+3) ou les segments adjacents (+1). √Ä 9 vies devenez un Killer et attaquez les autres. Doubles x2, Triples x3. √âlimin√© √† -1 vie. Le dernier debout gagne !",
                rulesClock: "<strong>Clock :</strong> Touchez 1 √† 10 dans l'ordre, puis finissez avec le Bull. Les doubles avancent de 2, les triples de 3. Si votre derni√®re fl√©chette touche la cible, tour suppl√©mentaire ! Le premier √† finir gagne. Apr√®s 10 tours chacun, le joueur le plus avanc√© gagne (√©galit√© possible).",

                // Alert
                selectContractAlert: "Veuillez s√©lectionner un contrat √† remplir ou barrer.",
                invalidScore: "Score invalide pour ce contrat !",
                invalidScoreDetail: "Pour {contract}, le score doit √™tre {rule}.",

                // Dart Input
                enterDarts: "Entrez Vos Fl√©chettes",
                dartsThrown: "Fl√©chettes Lanc√©es :",
                miss: "Rat√©",
                undo: "Annuler",
                clear: "Effacer",
                confirm: "Confirmer",

                // Killer
                chooseYourNumber: "choisissez votre num√©ro !",
                selectNumberPrompt: "Touchez un segment sur la cible",
                lives: "vies",
                killerLabel: "KILLER",
                eliminatedLabel: "√âLIMIN√â",
                numberTaken: "Ce num√©ro est d√©j√† pris !",
                enterYourDartsKiller: "Lancez vos 3 fl√©chettes",
                noNumberYet: "?",
                turnSummaryTitle: "R√©sum√© du Tour",

                // Clock
                clockTarget: "Cible :",
                clockFinished: "TERMIN√â",
                clockExtraTurn: "Derni√®re fl√©chette touch√©e ! Tour suppl√©mentaire !",
                clockThrowDarts: "Lancez vos 3 fl√©chettes",
                clockBull: "Bull",
                clockTurn: "Tour",

                // Tournament
                tournament: "Tournoi",
                tournamentDesc: "Tournoi √† √©limination directe. Choisissez un type de jeu, inscrivez les joueurs et jouez !",
                startTournament: "D√©marrer le Tournoi",
                tournamentBracket: "Tableau du Tournoi",
                selectMatchPlayers: "S√©lectionnez les joueurs pour le prochain match",
                startMatch: "Lancer le Match",
                backToTournament: "Retour au Tournoi",
                exitTournament: "Quitter le Tournoi",
                roundN: "Tour",
                semiFinals: "Demi-Finales",
                quarterFinals: "Quarts de Finale",
                final: "Finale",
                tournamentChampion: "Champion du Tournoi !",
                tournamentComplete: "Tournoi Termin√© !",
                tieResolution: "√âgalit√© ! S√©lectionnez le joueur qui avance :",
                newTournament: "Nouveau Tournoi",
                minPlayersTourn: "Ajoutez au moins 3 joueurs pour un tournoi",
                bye: "Exempt",
                matchVs: "contre",
                tournamentRegistrants: "Inscrits au Tournoi",
                matchScore: "Score",
                managePlayers: "G√©rer les Joueurs",
                addPlayer: "Ajouter un Joueur",
                addPlayerName: "Nom du nouveau joueur",
                removePlayer: "Retirer",
                withdrawn: "retir√©",
                playerAlreadyExists: "Ce joueur est d√©j√† dans le tournoi.",
                cannotRemoveInMatch: "Impossible de retirer un joueur en match.",

                // Contracts
                contracts: {
                    capital: { name: "Capital", desc: "3 premi√®res fl√©chettes - √©tablissez votre score de d√©part" },
                    "20": { name: "20", desc: "Touchez le segment 20" },
                    side: { name: "C√¥t√©", desc: "Touchez 3 segments adjacents (ex: 5-20-1). Le bull touche tous." },
                    "19": { name: "19", desc: "Touchez le segment 19" },
                    "3row": { name: "Suite", desc: "Touchez 3 num√©ros cons√©cutifs (ex: 14-15-16)" },
                    "18": { name: "18", desc: "Touchez le segment 18" },
                    color: { name: "Couleur", desc: "Touchez 3 couleurs diff√©rentes (noir, blanc, vert, rouge)" },
                    "17": { name: "17", desc: "Touchez le segment 17" },
                    double: { name: "Double", desc: "Touchez n'importe quel double" },
                    "16": { name: "16", desc: "Touchez le segment 16" },
                    triple: { name: "Triple", desc: "Touchez n'importe quel triple" },
                    "15": { name: "15", desc: "Touchez le segment 15" },
                    "57": { name: "57", desc: "Marquez exactement 57 avec 3 fl√©chettes" },
                    "14": { name: "14", desc: "Touchez le segment 14" },
                    bull: { name: "Bull", desc: "Touchez le centre (simple 25 ou double 50)" }
                }
            },
            es: {
                // Setup
                gameMode: "Modo de Juego",
                classic: "Cl√°sico",
                freeChoice: "Yahtzee Style",
                killer: "Killer",
                clock: "Clock",
                classicDesc: "Juega los contratos en orden. Acierta para sumar puntos, falla para dividir tu capital a la mitad.",
                freeChoiceDesc: "Elige d√≥nde registrar tu puntuaci√≥n. Completa o tacha contratos libremente.",
                killerDesc: "¬°Elige un n√∫mero, gana vidas, convi√©rtete en Killer y elimina a tus oponentes!",
                clockDesc: "¬°Acierta del 1 al 10 en orden, luego termina con Bull. Dobles y triples avanzan m√°s! √öltimo dardo en el objetivo = turno extra.",
                addPlayers: "A√±adir Jugadores",
                enterPlayerName: "Nombre del jugador",
                addPlayer: "A√±adir",
                startGame: "Comenzar",
                
                // Game
                enterScores: "Introduce las Puntuaciones de la Ronda",
                enterYourScore: "Introduce Tu Puntuaci√≥n",
                score: "Puntos:",
                currentCapital: "Capital actual:",
                startingRound: "Ronda inicial",
                previousRound: "‚Üê Ronda Anterior",
                previousTurn: "‚Üê Turno Anterior",
                submitRound: "Enviar",
                confirmChoice: "Confirmar",
                resetGame: "Reiniciar",
                chooseContract: "Elige un contrato para completar o tachar",
                selectContractFill: "Selecciona un Contrato para Completar:",
                scratchContract: "O Tacha un Contrato (puntuaci√≥n 0):",
                selectContract: "Selecciona un Contrato:",
                fillMode: "Completar Contrato",
                scratchMode: "Tachar Contrato",
                playerTurn: " - Tu turno",
                
                // Table
                round: "Ronda",
                contract: "Contrato",
                total: "TOTAL",
                
                // Winner
                itsATie: "¬°Empate!",
                tiedWith: "empatados con",
                points: "puntos",
                wins: "¬°Gana!",
                finalScore: "Puntuaci√≥n Final:",
                editScores: "‚Üê Editar",
                playAgain: "Jugar de Nuevo",
                
                // Rules
                gameRules: "üìã Reglas del Juego",
                rulesClassic: "<strong>Cl√°sico:</strong> Acierta el contrato para sumar tu puntuaci√≥n al capital. ¬°Falla y tu capital se divide a la mitad!",
                rulesFreeChoice: "<strong>Yahtzee Style:</strong> Elige d√≥nde registrar tu puntuaci√≥n cada turno. Tacha los contratos que no puedas completar (puntuaci√≥n 0).",
                rulesKiller: "<strong>Killer:</strong> Elige un n√∫mero, gana vidas toc√°ndolo (+3) o segmentos adyacentes (+1). A 9 vidas convi√©rtete en Killer y ataca a los dem√°s. Dobles x2, Triples x3. Eliminado a -1 vida. ¬°El √∫ltimo en pie gana!",
                rulesClock: "<strong>Clock:</strong> Acierta del 1 al 10 en orden, luego termina con Bull. Los dobles avanzan 2, los triples 3. Si tu √∫ltimo dardo acierta, ¬°turno extra! El primero en terminar gana. Despu√©s de 10 turnos cada uno, el jugador m√°s avanzado gana (empate posible).",

                // Alert
                selectContractAlert: "Por favor, selecciona un contrato para completar o tachar.",
                invalidScore: "¬°Puntuaci√≥n inv√°lida para este contrato!",
                invalidScoreDetail: "Para {contract}, la puntuaci√≥n debe ser {rule}.",

                // Dart Input
                enterDarts: "Introduce Tus Dardos",
                dartsThrown: "Dardos Lanzados:",
                miss: "Fallo",
                undo: "Deshacer",
                clear: "Borrar",
                confirm: "Confirmar",

                // Killer
                chooseYourNumber: "¬°elige tu n√∫mero!",
                selectNumberPrompt: "Toca un segmento en la diana",
                lives: "vidas",
                killerLabel: "KILLER",
                eliminatedLabel: "FUERA",
                numberTaken: "¬°Este n√∫mero ya est√° ocupado!",
                enterYourDartsKiller: "Lanza tus 3 dardos",
                noNumberYet: "?",
                turnSummaryTitle: "Resumen del Turno",

                // Clock
                clockTarget: "Objetivo:",
                clockFinished: "TERMINADO",
                clockExtraTurn: "¬°√öltimo dardo acertado! ¬°Turno extra!",
                clockThrowDarts: "Lanza tus 3 dardos",
                clockBull: "Bull",
                clockTurn: "Turno",

                // Tournament
                tournament: "Torneo",
                tournamentDesc: "Torneo de eliminaci√≥n directa. Elige un tipo de juego, registra jugadores y compite!",
                startTournament: "Iniciar Torneo",
                tournamentBracket: "Cuadro del Torneo",
                selectMatchPlayers: "Selecciona jugadores para el pr√≥ximo partido",
                startMatch: "Iniciar Partido",
                backToTournament: "Volver al Torneo",
                exitTournament: "Salir del Torneo",
                roundN: "Ronda",
                semiFinals: "Semifinales",
                quarterFinals: "Cuartos de Final",
                final: "Final",
                tournamentChampion: "¬°Campe√≥n del Torneo!",
                tournamentComplete: "¬°Torneo Completado!",
                tieResolution: "¬°Empate! Selecciona el jugador que avanza:",
                newTournament: "Nuevo Torneo",
                minPlayersTourn: "A√±ade al menos 3 jugadores para un torneo",
                bye: "Exento",
                matchVs: "contra",
                tournamentRegistrants: "Inscritos en el Torneo",
                matchScore: "Puntuaci√≥n",
                managePlayers: "Gestionar Jugadores",
                addPlayer: "Agregar Jugador",
                addPlayerName: "Nombre del nuevo jugador",
                removePlayer: "Eliminar",
                withdrawn: "retirado",
                playerAlreadyExists: "Este jugador ya est√° en el torneo.",
                cannotRemoveInMatch: "No se puede eliminar un jugador en partido activo.",

                // Contracts
                contracts: {
                    capital: { name: "Capital", desc: "3 primeros dardos - establece tu puntuaci√≥n inicial" },
                    "20": { name: "20", desc: "Acierta el segmento 20" },
                    side: { name: "Lado", desc: "Acierta 3 segmentos adyacentes (ej: 5-20-1). El bull toca todos." },
                    "19": { name: "19", desc: "Acierta el segmento 19" },
                    "3row": { name: "Escalera", desc: "Acierta 3 n√∫meros consecutivos (ej: 14-15-16)" },
                    "18": { name: "18", desc: "Acierta el segmento 18" },
                    color: { name: "Color", desc: "Acierta 3 colores diferentes (negro, blanco, verde, rojo)" },
                    "17": { name: "17", desc: "Acierta el segmento 17" },
                    double: { name: "Doble", desc: "Acierta cualquier doble" },
                    "16": { name: "16", desc: "Acierta el segmento 16" },
                    triple: { name: "Triple", desc: "Acierta cualquier triple" },
                    "15": { name: "15", desc: "Acierta el segmento 15" },
                    "57": { name: "57", desc: "Marca exactamente 57 con 3 dardos" },
                    "14": { name: "14", desc: "Acierta el segmento 14" },
                    bull: { name: "Bull", desc: "Acierta la diana (simple 25 o doble 50)" }
                }
            }
        };

        // CONTRACT_IDS, constants, and contract logic loaded from src/contracts.js

        // Current language
        let currentLang = 'en';

        // Game state
        let players = [];
        let gameMode = 'classic';
        let currentRound = 0;
        let currentPlayerIndex = 0;
        let scoresHidden = false;
        let selectedContract = null;
        let selectedScratch = null;
        let isScratchMode = false;
        let scores = {};
        let yahtzeeHistory = [];

        // Killer state
        let killerNumbers = {};
        let killerLives = {};
        let killerIsKiller = {};
        let killerEliminated = {};
        let killerPhase = 'number';
        let killerHistory = [];
        let killerDarts = [];
        let killerModifier = 'single';

        // Clock state
        let clockPosition = {};   // { playerName: currentTarget (1-10, then 11=bull) }
        let clockFinished = {};   // { playerName: boolean }
        let clockHistory = [];    // Turn history for undo
        let clockDarts = [];
        let clockModifier = 'single';
        let clockFinishOrder = []; // Track finish order for ranking

        // Dart input state
        let dartInputTargetField = null;
        let currentDarts = [];
        let currentModifier = 'single';
        let storedDarts = {}; // Store darts for each player: { playerKey: [dart1, dart2, dart3] }

        // Tournament state
        let tournamentMode = false;
        let tournamentState = null;
        let tournamentSelectedPlayers = [];

        // ==================== LOCAL STORAGE FUNCTIONS ====================

        const STORAGE_KEY = 'halveItGameState';

        function saveGameState() {
            const gameState = {
                // Setup state
                players: players,
                gameMode: gameMode,
                currentLang: currentLang,

                // Game state
                currentRound: currentRound,
                currentPlayerIndex: currentPlayerIndex,
                scores: scores,
                yahtzeeHistory: yahtzeeHistory,
                scoresHidden: scoresHidden,
                storedDarts: storedDarts,

                // Killer state
                killerNumbers: killerNumbers,
                killerLives: killerLives,
                killerIsKiller: killerIsKiller,
                killerEliminated: killerEliminated,
                killerPhase: killerPhase,
                killerHistory: killerHistory,

                // Clock state
                clockPosition: clockPosition,
                clockFinished: clockFinished,
                clockHistory: clockHistory,
                clockFinishOrder: clockFinishOrder,

                // Tournament state
                tournamentMode: tournamentMode,
                tournamentState: tournamentState,
                isTournamentHub: document.getElementById('tournamentHub') &&
                    !document.getElementById('tournamentHub').classList.contains('hidden'),

                // UI state
                isGameStarted: document.getElementById('gameBoard').style.display !== 'none',
                isWinnerShown: document.getElementById('winnerSection').style.display === 'block',

                // Timestamp for debugging
                savedAt: new Date().toISOString()
            };

            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
            } catch (e) {
                console.error('Failed to save game state:', e);
            }
        }

        function loadGameState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return false;

                const gameState = JSON.parse(saved);

                // Restore setup state
                players = gameState.players || [];
                gameMode = gameState.gameMode || 'classic';
                currentLang = gameState.currentLang || 'en';

                // Restore game state
                currentRound = gameState.currentRound || 0;
                currentPlayerIndex = gameState.currentPlayerIndex || 0;
                scores = gameState.scores || {};
                yahtzeeHistory = gameState.yahtzeeHistory || [];
                scoresHidden = gameState.scoresHidden || false;
                storedDarts = gameState.storedDarts || {};

                // Restore killer state
                killerNumbers = gameState.killerNumbers || {};
                killerLives = gameState.killerLives || {};
                killerIsKiller = gameState.killerIsKiller || {};
                killerEliminated = gameState.killerEliminated || {};
                killerPhase = gameState.killerPhase || 'number';
                killerHistory = gameState.killerHistory || [];

                // Restore clock state
                clockPosition = gameState.clockPosition || {};
                clockFinished = gameState.clockFinished || {};
                clockHistory = gameState.clockHistory || [];
                clockFinishOrder = gameState.clockFinishOrder || [];

                // Restore tournament state
                tournamentMode = gameState.tournamentMode || false;
                tournamentState = gameState.tournamentState || null;

                // Apply language (pass true to prevent saving during load)
                setLanguage(currentLang, true);

                // Restore UI state
                if (gameState.isGameStarted) {
                    // Hide setup, show game board
                    document.getElementById('setupSection').classList.add('hidden');
                    document.getElementById('gameBoard').style.display = 'block';

                    if (gameMode === 'classic') {
                        document.getElementById('classicRoundDisplay').classList.remove('hidden');
                        document.getElementById('classicInputSection').classList.remove('hidden');
                        document.getElementById('yahtzeePlayerDisplay').classList.add('hidden');
                        document.getElementById('yahtzeeInputSection').classList.add('hidden');
                        document.getElementById('hideScoresBtn').classList.add('hidden');

                        buildClassicTable();
                        updateRoundDisplay();
                        buildScoreInputs();
                        updatePrevButton();

                        // Restore scores in the table
                        players.forEach(player => {
                            const playerKey = player.replace(/\s/g, '_');
                            const playerData = scores[player];

                            if (playerData && playerData.rounds) {
                                playerData.rounds.forEach((round, i) => {
                                    const cell = document.getElementById(`cell-${playerKey}-${i}`);
                                    if (cell) {
                                        if (i === 0) {
                                            cell.textContent = round.score;
                                            cell.className = 'score-success';
                                        } else {
                                            if (round.success) {
                                                cell.textContent = `+${round.score}`;
                                                cell.className = 'score-success';
                                            } else {
                                                cell.textContent = `√∑2`;
                                                cell.className = 'score-fail';
                                            }
                                        }
                                    }
                                });

                                document.getElementById(`total-${playerKey}`).textContent = playerData.capital;
                            }
                        });

                        if (gameState.isWinnerShown) {
                            document.getElementById('classicInputSection').classList.add('hidden');
                            showWinner();
                        }
                    } else if (gameMode === 'yahtzee') {
                        document.getElementById('classicRoundDisplay').classList.add('hidden');
                        document.getElementById('classicInputSection').classList.add('hidden');
                        document.getElementById('yahtzeePlayerDisplay').classList.remove('hidden');
                        document.getElementById('yahtzeeInputSection').classList.remove('hidden');
                        document.getElementById('hideScoresBtn').classList.remove('hidden');

                        buildYahtzeeTable();

                        // Update display without clearing darts (since we just restored them)
                        const currentPlayer = players[currentPlayerIndex];
                        document.getElementById('currentPlayerName').textContent = `${currentPlayer}${t('playerTurn')}`;
                        selectedContract = null;
                        selectedScratch = null;
                        isScratchMode = false;

                        // Reset toggle buttons
                        document.getElementById('fillModeBtn').classList.add('active');
                        document.getElementById('fillModeBtn').classList.remove('scratch-active');
                        document.getElementById('scratchModeBtn').classList.remove('scratch-active');
                        document.getElementById('scratchModeBtn').classList.remove('active');

                        buildContractSelectors();
                        updateYahtzeePrevButton();
                        updateYahtzeeDartsDisplay();

                        // Restore scores in the table
                        players.forEach(player => {
                            const playerKey = player.replace(/\s/g, '_');
                            const playerData = scores[player];

                            if (playerData && playerData.contracts) {
                                CONTRACT_IDS.forEach(id => {
                                    const contractData = playerData.contracts[id];
                                    const cell = document.getElementById(`ycell-${playerKey}-${id}`);

                                    if (cell && contractData) {
                                        if (contractData.scratched) {
                                            cell.textContent = '‚úó';
                                            cell.className = 'score-cell cell-scratched';
                                        } else if (contractData.score !== null) {
                                            cell.textContent = contractData.score;
                                            cell.className = 'score-cell cell-filled';
                                        }
                                    }
                                });

                                const totalCell = document.getElementById(`ytotal-${playerKey}`);
                                if (totalCell) {
                                    totalCell.textContent = scoresHidden ? '???' : playerData.total;
                                }
                            }
                        });

                        updateScoreVisibility();

                        if (gameState.isWinnerShown) {
                            document.getElementById('yahtzeeInputSection').classList.add('hidden');
                            showWinner();
                        }
                    } else if (gameMode === 'killer') {
                        hideAllModeSections();
                        document.getElementById('killerBanner').classList.remove('hidden');
                        document.getElementById('killerDartboardSection').classList.remove('hidden');
                        document.getElementById('killerScoreboard').classList.remove('hidden');
                        document.getElementById('killerPrevSection').classList.remove('hidden');
                        document.querySelector('.scores-table').style.display = 'none';

                        updateKillerDisplay();
                        buildKillerScoreboard();
                        updateKillerPrevButton();

                        if (gameState.isWinnerShown) {
                            document.getElementById('killerDartboardSection').classList.add('hidden');
                            document.getElementById('killerPrevSection').classList.add('hidden');
                            showWinner();
                        }
                    } else if (gameMode === 'clock') {
                        hideAllModeSections();
                        document.getElementById('clockBanner').classList.remove('hidden');
                        document.getElementById('clockDartboardSection').classList.remove('hidden');
                        document.getElementById('clockScoreboard').classList.remove('hidden');
                        document.getElementById('clockPrevSection').classList.remove('hidden');
                        document.querySelector('.scores-table').style.display = 'none';

                        updateClockDisplay();
                        buildClockScoreboard();
                        updateClockPrevButton();

                        if (gameState.isWinnerShown) {
                            document.getElementById('clockDartboardSection').classList.add('hidden');
                            document.getElementById('clockPrevSection').classList.add('hidden');
                            showWinner();
                        }
                    }
                } else if (tournamentMode && tournamentState && gameState.isTournamentHub) {
                    // Restore tournament hub
                    document.getElementById('setupSection').classList.add('hidden');
                    document.getElementById('tournamentHub').classList.remove('hidden');

                    // Restore tournament checkbox
                    document.getElementById('tournamentCheckbox').checked = true;

                    if (tournamentState.champion) {
                        showTournamentChampion();
                    } else {
                        buildBracket();
                        buildPlayerRoster();
                        buildMatchPicker();
                    }
                } else {
                    // Still in setup phase
                    // Restore game mode selection
                    const modeRadio = document.querySelector(`input[name="gameMode"][value="${gameMode}"]`);
                    if (modeRadio) {
                        modeRadio.checked = true;
                    }

                    // Restore tournament checkbox state
                    if (tournamentMode) {
                        document.getElementById('tournamentCheckbox').checked = true;
                        const startBtn = document.getElementById('startBtn');
                        startBtn.setAttribute('data-i18n', 'startTournament');
                        startBtn.textContent = t('startTournament');
                    }

                    updatePlayerList();
                }

                return true;
            } catch (e) {
                console.error('Failed to load game state:', e);
                return false;
            }
        }

        function clearGameState() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.error('Failed to clear game state:', e);
            }
        }

        // ==================== LANGUAGE FUNCTIONS ====================

        function setLanguage(lang, fromLoad = false) {
            currentLang = lang;

            // Update language button states
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.onclick && btn.onclick.toString().includes(`'${lang}'`)) {
                    btn.classList.add('active');
                }
            });

            applyTranslations();
            buildRulesGrid();
            updateModeDescription();

            if (!fromLoad) {
                saveGameState();
            }
        }

        function t(key) {
            return translations[currentLang][key] || translations['en'][key] || key;
        }

        function getContractName(id) {
            return translations[currentLang].contracts[id]?.name || id;
        }

        function getContractDesc(id) {
            return translations[currentLang].contracts[id]?.desc || '';
        }

        function applyTranslations() {
            // Apply text translations
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[currentLang][key]) {
                    if (key === 'rulesClassic' || key === 'rulesFreeChoice' || key === 'rulesKiller' || key === 'rulesClock') {
                        el.innerHTML = translations[currentLang][key];
                    } else {
                        el.textContent = translations[currentLang][key];
                    }
                }
            });
            
            // Apply placeholder translations
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (translations[currentLang][key]) {
                    el.placeholder = translations[currentLang][key];
                }
            });
        }

        function buildRulesGrid() {
            const grid = document.getElementById('rulesGrid');
            grid.innerHTML = CONTRACT_IDS.map(id => `
                <div class="rule-item"><strong>${getContractName(id)}:</strong> ${getContractDesc(id)}</div>
            `).join('');
        }

        // ==================== SETUP FUNCTIONS ====================

        function updateModeDescription() {
            const mode = document.querySelector('input[name="gameMode"]:checked').value;
            const desc = document.getElementById('modeDescription');
            if (mode === 'classic') desc.textContent = t('classicDesc');
            else if (mode === 'yahtzee') desc.textContent = t('freeChoiceDesc');
            else if (mode === 'killer') desc.textContent = t('killerDesc');
            else if (mode === 'clock') desc.textContent = t('clockDesc');
        }

        function addPlayer() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();

            if (name && !players.includes(name)) {
                players.push(name);
                updatePlayerList();
                input.value = '';
                saveGameState();
            }
            input.focus();
        }

        function removePlayer(name) {
            players = players.filter(p => p !== name);
            updatePlayerList();
            saveGameState();
        }

        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = players.map(p => `
                <div class="player-tag">
                    ${p}
                    <button onclick="removePlayer('${p}')" class="btn-small">√ó</button>
                </div>
            `).join('');
            
            const minPlayers = tournamentMode ? 3 : 1;
            document.getElementById('startBtn').style.display = players.length >= minPlayers ? 'block' : 'none';
        }

        function hideAllModeSections() {
            document.getElementById('classicRoundDisplay').classList.add('hidden');
            document.getElementById('classicInputSection').classList.add('hidden');
            document.getElementById('yahtzeePlayerDisplay').classList.add('hidden');
            document.getElementById('yahtzeeInputSection').classList.add('hidden');
            document.getElementById('hideScoresBtn').classList.add('hidden');
            document.getElementById('killerBanner').classList.add('hidden');
            document.getElementById('killerDartboardSection').classList.add('hidden');
            document.getElementById('killerScoreboard').classList.add('hidden');
            document.getElementById('killerTurnSummary').classList.add('hidden');
            document.getElementById('killerPrevSection').classList.add('hidden');
            document.getElementById('clockBanner').classList.add('hidden');
            document.getElementById('clockDartboardSection').classList.add('hidden');
            document.getElementById('clockScoreboard').classList.add('hidden');
            document.getElementById('clockPrevSection').classList.add('hidden');
            document.querySelector('.scores-table').style.display = '';
        }

        function handleStartClick() {
            if (tournamentMode) {
                startTournament();
            } else {
                startGame();
            }
        }

        function startGame() {
            if (!tournamentMode) {
                gameMode = document.querySelector('input[name="gameMode"]:checked').value;
            }
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('gameBoard').style.display = 'block';
            currentRound = 0;
            currentPlayerIndex = 0;
            storedDarts = {};

            hideAllModeSections();

            if (gameMode === 'classic') {
                players.forEach(p => {
                    scores[p] = { capital: 0, rounds: [] };
                });
                document.getElementById('classicRoundDisplay').classList.remove('hidden');
                document.getElementById('classicInputSection').classList.remove('hidden');
                buildClassicTable();
                updateRoundDisplay();
                buildScoreInputs();
                updatePrevButton();
            } else if (gameMode === 'yahtzee') {
                yahtzeeHistory = [];
                players.forEach(p => {
                    scores[p] = {
                        contracts: {},
                        total: 0
                    };
                    CONTRACT_IDS.forEach(id => {
                        scores[p].contracts[id] = { score: null, scratched: false };
                    });
                });
                document.getElementById('yahtzeePlayerDisplay').classList.remove('hidden');
                document.getElementById('yahtzeeInputSection').classList.remove('hidden');
                document.getElementById('hideScoresBtn').classList.remove('hidden');
                buildYahtzeeTable();
                updateYahtzeeDisplay();
                updateYahtzeePrevButton();
            } else if (gameMode === 'killer') {
                killerNumbers = {};
                killerLives = {};
                killerIsKiller = {};
                killerEliminated = {};
                killerPhase = 'number';
                killerHistory = [];
                killerDarts = [];
                killerModifier = 'single';
                players.forEach(p => {
                    killerLives[p] = 0;
                    killerIsKiller[p] = false;
                    killerEliminated[p] = false;
                });
                document.getElementById('killerBanner').classList.remove('hidden');
                document.getElementById('killerDartboardSection').classList.remove('hidden');
                document.getElementById('killerScoreboard').classList.remove('hidden');
                document.getElementById('killerPrevSection').classList.remove('hidden');
                document.querySelector('.scores-table').style.display = 'none';
                updateKillerDisplay();
                buildKillerScoreboard();
            } else if (gameMode === 'clock') {
                clockPosition = {};
                clockFinished = {};
                clockHistory = [];
                clockDarts = [];
                clockModifier = 'single';
                clockFinishOrder = [];
                players.forEach(p => {
                    clockPosition[p] = 1;
                    clockFinished[p] = false;
                });
                document.getElementById('clockBanner').classList.remove('hidden');
                document.getElementById('clockDartboardSection').classList.remove('hidden');
                document.getElementById('clockScoreboard').classList.remove('hidden');
                document.getElementById('clockPrevSection').classList.remove('hidden');
                document.querySelector('.scores-table').style.display = 'none';
                updateClockDisplay();
                buildClockScoreboard();
            }
            saveGameState();
        }

        // ==================== CLASSIC MODE ====================
        
        function buildClassicTable() {
            const head = document.getElementById('tableHead');
            const body = document.getElementById('tableBody');
            
            let headerHTML = `<tr><th>${t('round')}</th>`;
            players.forEach(player => {
                headerHTML += `<th>${player}</th>`;
            });
            headerHTML += '</tr>';
            head.innerHTML = headerHTML;
            
            let bodyHTML = '';
            CONTRACT_IDS.forEach((id, i) => {
                bodyHTML += `<tr id="row-${i}" class="${i === currentRound ? 'round-current' : ''}">
                    <td class="round-name-cell">${getContractName(id)}</td>`;
                players.forEach(player => {
                    const playerKey = player.replace(/\s/g, '_');
                    bodyHTML += `<td id="cell-${playerKey}-${i}">-</td>`;
                });
                bodyHTML += '</tr>';
            });
            
            bodyHTML += `<tr class="total-row"><td class="round-name-cell">${t('total')}</td>`;
            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                bodyHTML += `<td id="total-${playerKey}">0</td>`;
            });
            bodyHTML += '</tr>';
            
            body.innerHTML = bodyHTML;
        }

        function updateRoundDisplay() {
            const contractId = CONTRACT_IDS[currentRound];
            document.getElementById('currentRoundName').textContent = getContractName(contractId);
            document.getElementById('currentRoundDesc').textContent = getContractDesc(contractId);
            
            CONTRACT_IDS.forEach((id, i) => {
                const row = document.getElementById(`row-${i}`);
                if (row) {
                    row.classList.toggle('round-current', i === currentRound);
                }
            });
        }

        function buildScoreInputs() {
            const container = document.getElementById('scoreInputs');

            container.innerHTML = players.map(player => {
                const playerData = scores[player];
                const capitalDisplay = currentRound === 0 ? t('startingRound') : `${t('currentCapital')} ${playerData.capital}`;
                const inputId = `score-${player.replace(/\s/g, '_')}`;

                // Check if player has entered darts
                const playerDarts = storedDarts[inputId];
                let dartsDisplay = '';
                if (playerDarts && playerDarts.length > 0) {
                    dartsDisplay = playerDarts.map(d => d.displayText).join(', ');
                } else {
                    dartsDisplay = '<span style="color: #636e72;">No darts entered</span>';
                }

                return `
                    <div class="player-score-card">
                        <h4>${player}</h4>
                        <div class="current-capital">${capitalDisplay}</div>
                        <div class="score-row" style="flex-direction: column; align-items: stretch;">
                            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px; text-align: center;">
                                ${dartsDisplay}
                            </div>
                            <button class="dart-input-btn" onclick="openDartInputClassic('${inputId}')" title="Enter darts" style="width: 100%;">üéØ ${t('enterDarts')}</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function editLastRound() {
            document.getElementById('winnerSection').style.display = 'none';

            if (gameMode === 'classic') {
                document.getElementById('classicInputSection').classList.remove('hidden');
                previousRound();
            } else if (gameMode === 'yahtzee') {
                document.getElementById('yahtzeeInputSection').classList.remove('hidden');
                previousYahtzeeTurn();
            } else if (gameMode === 'killer') {
                document.getElementById('killerDartboardSection').classList.remove('hidden');
                document.getElementById('killerPrevSection').classList.remove('hidden');
                previousKillerTurn();
            } else if (gameMode === 'clock') {
                document.getElementById('clockDartboardSection').classList.remove('hidden');
                document.getElementById('clockPrevSection').classList.remove('hidden');
                previousClockTurn();
            }
        }

        function previousRound() {
            if (currentRound === 0) return;

            currentRound--;

            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                const lastRound = scores[player].rounds.pop();

                // Restore darts from the last round
                const inputId = `score-${playerKey}`;
                if (lastRound && lastRound.darts) {
                    storedDarts[inputId] = [...lastRound.darts];
                }

                if (scores[player].rounds.length > 0) {
                    scores[player].capital = scores[player].rounds[scores[player].rounds.length - 1].capitalAfter;
                } else {
                    scores[player].capital = 0;
                }

                const cell = document.getElementById(`cell-${playerKey}-${currentRound}`);
                cell.textContent = '-';
                cell.className = '';

                document.getElementById(`total-${playerKey}`).textContent = scores[player].capital;
            });

            updateRoundDisplay();
            buildScoreInputs();
            updatePrevButton();
            saveGameState();
        }

        function updatePrevButton() {
            document.getElementById('prevBtn').style.display = currentRound > 0 ? 'inline-block' : 'none';
        }

        function submitRound() {
            const contractId = CONTRACT_IDS[currentRound];

            // Check if all players have entered darts
            for (let player of players) {
                const playerKey = player.replace(/\s/g, '_');
                const inputId = `score-${playerKey}`;
                const playerDarts = storedDarts[inputId];

                if (!playerDarts || playerDarts.length === 0) {
                    alert(`${player} has not entered darts yet!`);
                    return;
                }
                if (playerDarts.length < 3) {
                    alert(`${player} must enter exactly 3 darts!`);
                    return;
                }
            }

            // Calculate scores from darts
            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                const inputId = `score-${playerKey}`;
                const playerDarts = storedDarts[inputId];

                let score;
                if (currentRound === 0) {
                    // Capital: Use total score from darts
                    score = playerDarts.reduce((sum, d) => sum + d.score, 0);
                } else {
                    // Check if darts meet contract requirements
                    const meetsRequirements = checkContractRequirements(playerDarts, contractId);

                    if (!meetsRequirements) {
                        // If requirements not met, score is 0 (capital will be halved)
                        score = 0;
                    } else {
                        // Requirements met, calculate score
                        // Check for non-numeric contracts first (can't use parseInt because '3row' parses to 3)
                        const nonNumericContracts = ['capital', 'side', '3row', 'color', 'double', 'triple', '57', 'bull'];
                        if (nonNumericContracts.includes(contractId)) {
                            // For special contracts, use appropriate scoring
                            if (contractId === 'double') {
                                score = playerDarts.filter(d => d.modifier === 'double').reduce((sum, d) => sum + d.score, 0);
                            } else if (contractId === 'triple') {
                                score = playerDarts.filter(d => d.modifier === 'triple').reduce((sum, d) => sum + d.score, 0);
                            } else if (contractId === 'bull') {
                                score = playerDarts.filter(d => d.number === 25).reduce((sum, d) => sum + d.score, 0);
                            } else {
                                // For capital, side, 3row, color, 57: use total score
                                score = playerDarts.reduce((sum, d) => sum + d.score, 0);
                            }
                        } else {
                            // For numeric contracts (20, 19, 18, 17, 16, 15, 14)
                            const targetNumber = parseInt(contractId);
                            score = calculateClassicScore(playerDarts, targetNumber);
                        }
                    }
                }

                // Validate score
                if (!validateScore(score, contractId)) {
                    showValidationError(contractId);
                    return;
                }

                if (currentRound === 0) {
                    scores[player].capital = score;
                    scores[player].rounds.push({
                        score: score,
                        success: true,
                        capitalAfter: score,
                        darts: [...playerDarts]
                    });

                    const cell = document.getElementById(`cell-${playerKey}-${currentRound}`);
                    cell.textContent = score;
                    cell.className = 'score-success';
                } else {
                    const success = score > 0;
                    let newCapital;

                    if (success) {
                        newCapital = scores[player].capital + score;
                    } else {
                        newCapital = Math.ceil(scores[player].capital / 2);
                    }

                    scores[player].rounds.push({
                        score: score,
                        success: success,
                        capitalAfter: newCapital,
                        darts: [...playerDarts]
                    });

                    const cell = document.getElementById(`cell-${playerKey}-${currentRound}`);
                    if (success) {
                        cell.textContent = `+${score}`;
                        cell.className = 'score-success';
                    } else {
                        cell.textContent = `√∑2`;
                        cell.className = 'score-fail';
                    }

                    scores[player].capital = newCapital;
                }

                document.getElementById(`total-${playerKey}`).textContent = scores[player].capital;
            });

            // Clear stored darts for next round
            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                const inputId = `score-${playerKey}`;
                delete storedDarts[inputId];
            });

            currentRound++;

            if (currentRound >= CONTRACT_IDS.length) {
                showWinner();
            } else {
                updateRoundDisplay();
                buildScoreInputs();
                updatePrevButton();
            }
            saveGameState();
        }

        // ==================== YAHTZEE MODE ====================

        function buildYahtzeeTable() {
            const head = document.getElementById('tableHead');
            const body = document.getElementById('tableBody');
            
            let headerHTML = `<tr><th>${t('contract')}</th>`;
            players.forEach(player => {
                headerHTML += `<th>${player}</th>`;
            });
            headerHTML += '</tr>';
            head.innerHTML = headerHTML;
            
            let bodyHTML = '';
            CONTRACT_IDS.forEach((id) => {
                bodyHTML += `<tr id="yrow-${id}">
                    <td class="round-name-cell">${getContractName(id)}</td>`;
                players.forEach(player => {
                    const playerKey = player.replace(/\s/g, '_');
                    bodyHTML += `<td id="ycell-${playerKey}-${id}" class="score-cell">-</td>`;
                });
                bodyHTML += '</tr>';
            });
            
            bodyHTML += `<tr class="total-row"><td class="round-name-cell">${t('total')}</td>`;
            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                bodyHTML += `<td id="ytotal-${playerKey}">0</td>`;
            });
            bodyHTML += '</tr>';
            
            body.innerHTML = bodyHTML;
        }

        function updateYahtzeeDisplay() {
            const currentPlayer = players[currentPlayerIndex];
            document.getElementById('currentPlayerName').textContent = `${currentPlayer}${t('playerTurn')}`;
            selectedContract = null;
            selectedScratch = null;
            isScratchMode = false;

            // Clear darts for new player
            delete storedDarts['yahtzeeCurrentDarts'];
            updateYahtzeeDartsDisplay();

            // Reset toggle buttons
            document.getElementById('fillModeBtn').classList.add('active');
            document.getElementById('fillModeBtn').classList.remove('scratch-active');
            document.getElementById('scratchModeBtn').classList.remove('scratch-active');
            document.getElementById('scratchModeBtn').classList.remove('active');

            buildContractSelectors();
            updateYahtzeePrevButton();
        }

        function toggleScratchMode(scratchMode) {
            isScratchMode = scratchMode;

            // Update toggle buttons
            const fillBtn = document.getElementById('fillModeBtn');
            const scratchBtn = document.getElementById('scratchModeBtn');

            if (isScratchMode) {
                fillBtn.classList.remove('active');
                scratchBtn.classList.add('scratch-active');
                scratchBtn.classList.add('active');
            } else {
                fillBtn.classList.add('active');
                scratchBtn.classList.remove('scratch-active');
                scratchBtn.classList.remove('active');
            }

            // Clear selection
            selectedContract = null;
            selectedScratch = null;

            // Update contract buttons visual feedback
            buildContractSelectors();
        }

        function buildContractSelectors() {
            const currentPlayer = players[currentPlayerIndex];
            const playerContracts = scores[currentPlayer].contracts;

            const contractSelector = document.getElementById('contractSelector');

            // Get valid contracts based on entered darts
            const darts = storedDarts['yahtzeeCurrentDarts'];
            const validContracts = darts ? getValidContracts(darts) : [];

            let html = '';

            CONTRACT_IDS.forEach(id => {
                const contractData = playerContracts[id];
                const isUsed = contractData.score !== null || contractData.scratched;
                const name = getContractName(id);
                const isValid = validContracts.includes(id);

                if (isUsed) {
                    const status = contractData.scratched ? '‚úó' : `${contractData.score}`;
                    html += `<button class="contract-btn" disabled>${name}<br><small>${status}</small></button>`;
                } else {
                    // Apply scratch-mode class if in scratch mode
                    let classes = 'contract-btn';
                    if (isScratchMode) {
                        classes += ' scratch-mode';
                    }
                    // Check if this contract is currently selected
                    const isSelected = (selectedContract === id) || (selectedScratch === id);
                    if (isSelected) {
                        classes += ' selected';
                    }
                    // Build inline style for highlighting
                    let style = '';
                    if (isSelected) {
                        // Selected: blue border and background
                        style = ' style="border-color: #3282b8; border-width: 3px; background: #3282b8;"';
                    } else if (isValid && darts) {
                        // Valid but not selected: green border
                        style = ' style="border-color: #00b894; border-width: 3px; background: rgba(0, 184, 148, 0.2);"';
                    }
                    html += `<button class="${classes}" id="contract-${id}" onclick="selectContractUnified('${id}')"${style}>${name}${isValid && darts ? ' ‚úì' : ''}</button>`;
                }
            });

            contractSelector.innerHTML = html;
        }

        function selectContractUnified(contractId) {
            if (isScratchMode) {
                selectedContract = null;
                selectedScratch = contractId;
            } else {
                selectedScratch = null;
                selectedContract = contractId;
            }

            // Rebuild contract selectors to show the selection with proper styling
            buildContractSelectors();
        }

        function submitYahtzeeChoice() {
            const currentPlayer = players[currentPlayerIndex];
            const playerKey = currentPlayer.replace(/\s/g, '_');

            if (!selectedContract && !selectedScratch) {
                alert(t('selectContractAlert'));
                return;
            }

            // Check if darts have been entered (only required for fill mode)
            const darts = storedDarts['yahtzeeCurrentDarts'];
            if (selectedContract && (!darts || darts.length === 0)) {
                alert('Please enter your darts first!');
                return;
            }
            if (selectedContract && darts && darts.length < 3) {
                alert('You must enter exactly 3 darts!');
                return;
            }

            // Validate that the selected contract is valid for the entered darts
            if (selectedContract) {
                const validContracts = getValidContracts(darts);
                if (!validContracts.includes(selectedContract)) {
                    const contractName = getContractName(selectedContract);
                    alert(`The selected contract "${contractName}" is not valid for your darts. Please select a valid contract (highlighted in green with ‚úì).`);
                    return;
                }
            }

            // Calculate score from darts
            let score = 0;
            if (selectedContract) {
                score = calculateContractScore(darts, selectedContract);
            }

            yahtzeeHistory.push({
                playerIndex: currentPlayerIndex,
                player: currentPlayer,
                contractId: selectedContract || selectedScratch,
                wasScratched: !!selectedScratch,
                score: selectedContract ? score : 0,
                darts: darts ? [...darts] : []
            });

            if (selectedContract) {
                scores[currentPlayer].contracts[selectedContract].score = score;
                scores[currentPlayer].total += score;

                const cell = document.getElementById(`ycell-${playerKey}-${selectedContract}`);
                cell.textContent = score;
                cell.className = 'score-cell cell-filled';
            } else {
                scores[currentPlayer].contracts[selectedScratch].scratched = true;

                const cell = document.getElementById(`ycell-${playerKey}-${selectedScratch}`);
                cell.textContent = '‚úó';
                cell.className = 'score-cell cell-scratched';
            }

            const totalCell = document.getElementById(`ytotal-${playerKey}`);
            if (scoresHidden) {
                totalCell.textContent = '???';
            } else {
                totalCell.textContent = scores[currentPlayer].total;
            }

            updateScoreVisibility();
            updateYahtzeePrevButton();
            moveToNextPlayer();
            saveGameState();
        }

        function moveToNextPlayer() {
            let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;
            let checkedPlayers = 0;
            
            while (checkedPlayers < players.length) {
                const player = players[nextPlayerIndex];
                const hasAvailable = CONTRACT_IDS.some(id => {
                    const data = scores[player].contracts[id];
                    return data.score === null && !data.scratched;
                });
                
                if (hasAvailable) {
                    currentPlayerIndex = nextPlayerIndex;
                    updateYahtzeeDisplay();
                    return;
                }
                
                nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
                checkedPlayers++;
            }
            
            showWinner();
        }

        function updateYahtzeePrevButton() {
            document.getElementById('yahtzeePrevBtn').style.display = yahtzeeHistory.length > 0 ? 'inline-block' : 'none';
        }

        function previousYahtzeeTurn() {
            if (yahtzeeHistory.length === 0) return;

            const lastMove = yahtzeeHistory.pop();
            const player = lastMove.player;
            const playerKey = player.replace(/\s/g, '_');
            const contractId = lastMove.contractId;

            if (lastMove.wasScratched) {
                scores[player].contracts[contractId].scratched = false;
            } else {
                scores[player].contracts[contractId].score = null;
                scores[player].total -= lastMove.score;
            }

            const cell = document.getElementById(`ycell-${playerKey}-${contractId}`);
            cell.textContent = '-';
            cell.className = 'score-cell';
            cell.classList.remove('score-hidden');

            const totalCell = document.getElementById(`ytotal-${playerKey}`);
            if (scoresHidden) {
                totalCell.textContent = '???';
            } else {
                totalCell.textContent = scores[player].total;
            }

            currentPlayerIndex = lastMove.playerIndex;

            // Restore darts from the last move
            if (lastMove.darts && lastMove.darts.length > 0) {
                storedDarts['yahtzeeCurrentDarts'] = [...lastMove.darts];
                updateYahtzeeDartsDisplay();
            } else {
                delete storedDarts['yahtzeeCurrentDarts'];
                updateYahtzeeDartsDisplay();
            }

            // Update display
            selectedContract = null;
            selectedScratch = null;
            isScratchMode = false;

            // Reset toggle buttons
            document.getElementById('fillModeBtn').classList.add('active');
            document.getElementById('fillModeBtn').classList.remove('scratch-active');
            document.getElementById('scratchModeBtn').classList.remove('scratch-active');
            document.getElementById('scratchModeBtn').classList.remove('active');

            document.getElementById('currentPlayerName').textContent = `${player}${t('playerTurn')}`;
            buildContractSelectors();
            updateYahtzeePrevButton();
            saveGameState();
        }

        function toggleScoreVisibility() {
            scoresHidden = !scoresHidden;
            document.getElementById('hideScoresBtn').textContent = scoresHidden ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è';
            updateScoreVisibility();
            saveGameState();
        }

        function updateScoreVisibility() {
            if (gameMode !== 'yahtzee') return;
            
            players.forEach(player => {
                const playerKey = player.replace(/\s/g, '_');
                
                CONTRACT_IDS.forEach(id => {
                    const cell = document.getElementById(`ycell-${playerKey}-${id}`);
                    if (cell) {
                        const data = scores[player].contracts[id];
                        if (data.score !== null || data.scratched) {
                            cell.classList.toggle('score-hidden', scoresHidden);
                        }
                    }
                });
                
                const totalCell = document.getElementById(`ytotal-${playerKey}`);
                if (totalCell) {
                    if (scoresHidden) {
                        totalCell.textContent = '???';
                        totalCell.classList.add('score-hidden');
                    } else {
                        totalCell.textContent = scores[player].total;
                        totalCell.classList.remove('score-hidden');
                    }
                }
            });
        }

        // ==================== KILLER MODE ====================

        function getAdjacentNumbers(num) {
            if (num === 0 || num === 25) return [];
            const idx = DARTBOARD_SEQUENCE.indexOf(num);
            if (idx === -1) return [];
            const left = DARTBOARD_SEQUENCE[(idx - 1 + DARTBOARD_SEQUENCE.length) % DARTBOARD_SEQUENCE.length];
            const right = DARTBOARD_SEQUENCE[(idx + 1) % DARTBOARD_SEQUENCE.length];
            return [left, right];
        }

        function buildKillerNumberGrid() {
            const grid = document.getElementById('killerNumberGrid');
            const takenNumbers = Object.values(killerNumbers);
            let html = '<div class="killer-number-selection-grid">';
            for (let i = 1; i <= 20; i++) {
                const taken = takenNumbers.includes(i);
                const cls = taken ? 'killer-num-btn taken' : 'killer-num-btn';
                const onclick = taken ? '' : `onclick="selectKillerNumber(${i})"`;
                html += `<button class="${cls}" ${onclick}>${i}</button>`;
            }
            html += '</div>';
            grid.innerHTML = html;
        }

        function buildKillerPlayGrid() {
            const grid = document.getElementById('killerNumberGrid');
            const currentPlayer = players[currentPlayerIndex];
            let html = '';

            for (const player of players) {
                if (killerEliminated[player]) continue;
                const num = killerNumbers[player];
                const adj = getAdjacentNumbers(num);
                const isSelf = player === currentPlayer;
                const labelClass = 'killer-player-row-label' + (isSelf ? ' is-self' : '');

                html += `<div class="killer-player-row">`;
                html += `<div class="${labelClass}">${player}</div>`;
                html += `<div class="killer-player-row-buttons">`;
                html += `<button class="killer-num-btn adj-number" onclick="addKillerDart(${adj[0]})">${adj[0]}</button>`;
                html += `<button class="killer-num-btn own-number" onclick="addKillerDart(${num})">${num}</button>`;
                html += `<button class="killer-num-btn adj-number" onclick="addKillerDart(${adj[1]})">${adj[1]}</button>`;
                html += `</div>`;
                html += `</div>`;
            }

            html += `<div class="killer-miss-row">`;
            html += `<button class="killer-num-btn miss-btn" onclick="addKillerDart(0)"><span data-i18n="miss">${t('miss')}</span></button>`;
            html += `</div>`;
            grid.innerHTML = html;
        }

        function updateKillerDisplay() {
            const banner = document.getElementById('killerBanner');
            const bannerText = document.getElementById('killerBannerText');
            const bannerSub = document.getElementById('killerBannerSub');
            const modifiers = document.getElementById('killerModifiers');
            const dartsDisplay = document.getElementById('killerDartsDisplay');
            const confirmBtn = document.getElementById('killerConfirmBtn');
            const actions = document.getElementById('killerActions');

            const currentPlayer = players[currentPlayerIndex];

            if (killerPhase === 'number') {
                bannerText.textContent = `${currentPlayer}, ${t('chooseYourNumber')}`;
                bannerSub.textContent = t('selectNumberPrompt');
                modifiers.style.display = 'none';
                dartsDisplay.style.display = 'none';
                confirmBtn.style.display = 'none';
                actions.style.display = currentPlayerIndex > 0 ? 'flex' : 'none';
                buildKillerNumberGrid();
            } else {
                const lives = killerLives[currentPlayer];
                const isK = killerIsKiller[currentPlayer];
                const playerNum = killerNumbers[currentPlayer];
                let bannerHtml = `${currentPlayer} <span class="killer-number-badge">#${playerNum}</span>`;
                if (isK) bannerHtml += ` <span class="killer-badge-banner">${t('killerLabel')}</span>`;
                bannerText.innerHTML = bannerHtml;
                bannerSub.textContent = `${lives} ${t('lives')} ‚Äî ${t('enterYourDartsKiller')}`;
                modifiers.style.display = 'flex';
                dartsDisplay.style.display = 'flex';
                confirmBtn.style.display = '';
                actions.style.display = 'flex';
                killerDarts = [];
                killerModifier = 'single';
                setKillerModifier('single');
                updateKillerDartsDisplay();
                buildKillerPlayGrid();
            }
        }

        function buildKillerScoreboard() {
            const container = document.getElementById('killerScoreboard');
            const currentPlayer = players[currentPlayerIndex];
            let html = '';

            players.forEach(player => {
                const num = killerNumbers[player];
                const lives = killerLives[player] || 0;
                const isK = killerIsKiller[player];
                const elim = killerEliminated[player];
                const isCurrent = (player === currentPlayer && !elim);

                let cardClass = 'killer-player-card';
                if (isCurrent) cardClass += ' current-turn';
                if (isK && !elim) cardClass += ' is-killer';
                if (elim) cardClass += ' eliminated';

                const livesPercent = Math.min(Math.max(lives, 0), 9) / 9 * 100;
                const fillClass = isK ? 'killer-lives-fill killer-level' : 'killer-lives-fill';

                html += `<div class="${cardClass}">`;
                html += `<div class="player-name">${player}</div>`;
                html += `<div class="player-number">#${num !== undefined ? num : t('noNumberYet')}</div>`;
                html += `<div class="killer-lives-bar"><div class="${fillClass}" style="width:${livesPercent}%"></div></div>`;
                html += `<div class="killer-lives-count">${lives} ${t('lives')}</div>`;
                if (elim) {
                    html += `<div class="killer-eliminated-badge">${t('eliminatedLabel')}</div>`;
                } else if (isK) {
                    html += `<div class="killer-badge">${t('killerLabel')}</div>`;
                }
                html += `</div>`;
            });

            container.innerHTML = html;
        }

        function selectKillerNumber(number) {
            const takenNumbers = Object.values(killerNumbers);
            if (takenNumbers.includes(number)) return;

            const currentPlayer = players[currentPlayerIndex];
            killerNumbers[currentPlayer] = number;

            currentPlayerIndex++;
            if (currentPlayerIndex >= players.length) {
                killerPhase = 'play';
                currentPlayerIndex = 0;
            }

            updateKillerDisplay();
            buildKillerScoreboard();
            saveGameState();
        }

        function setKillerModifier(modifier) {
            killerModifier = modifier;
            document.getElementById('killerSingleBtn').classList.remove('active');
            document.getElementById('killerDoubleBtn').classList.remove('active');
            document.getElementById('killerTripleBtn').classList.remove('active');
            document.getElementById('killer' + modifier.charAt(0).toUpperCase() + modifier.slice(1) + 'Btn').classList.add('active');
        }

        function addKillerDart(number) {
            if (killerDarts.length >= 3) return;

            let score = number;
            let displayText = '';
            let modifier = killerModifier;

            if (number === 25) {
                if (killerModifier === 'double') {
                    score = 50;
                    displayText = 'Bull√ó2';
                } else {
                    score = 25;
                    displayText = 'Bull';
                    modifier = 'single';
                }
            } else if (number === 0) {
                score = 0;
                displayText = t('miss');
                modifier = 'miss';
            } else {
                if (killerModifier === 'double') {
                    score = number * 2;
                    displayText = `D${number}`;
                } else if (killerModifier === 'triple') {
                    score = number * 3;
                    displayText = `T${number}`;
                } else {
                    score = number;
                    displayText = `${number}`;
                }
            }

            killerDarts.push({ number, modifier, score, displayText });
            updateKillerDartsDisplay();
            setKillerModifier('single');
        }

        function clearLastKillerDart() {
            if (killerPhase === 'number') {
                if (currentPlayerIndex > 0) {
                    currentPlayerIndex--;
                    const prevPlayer = players[currentPlayerIndex];
                    delete killerNumbers[prevPlayer];
                    updateKillerDisplay();
                    buildKillerScoreboard();
                    saveGameState();
                }
                return;
            }
            if (killerDarts.length > 0) {
                killerDarts.pop();
                updateKillerDartsDisplay();
            } else if (killerHistory.length === 0) {
                // No darts entered and no turns played yet: go back to number phase
                killerPhase = 'number';
                currentPlayerIndex = players.length - 1;
                const lastPlayer = players[currentPlayerIndex];
                delete killerNumbers[lastPlayer];
                updateKillerDisplay();
                buildKillerScoreboard();
                saveGameState();
            }
        }

        function clearAllKillerDarts() {
            if (killerPhase === 'number') {
                if (currentPlayerIndex > 0) {
                    killerNumbers = {};
                    currentPlayerIndex = 0;
                    updateKillerDisplay();
                    buildKillerScoreboard();
                    saveGameState();
                }
                return;
            }
            killerDarts = [];
            updateKillerDartsDisplay();
        }

        function updateKillerDartsDisplay() {
            for (let i = 0; i < 3; i++) {
                const slot = document.getElementById(`killerDart${i + 1}`);
                if (i < killerDarts.length) {
                    slot.textContent = killerDarts[i].displayText;
                    slot.classList.add('filled');
                    slot.classList.remove('empty');
                } else {
                    slot.textContent = '-';
                    slot.classList.remove('filled');
                }
            }
        }

        function processKillerDarts(thrower, darts) {
            const changes = [];
            const throwerNum = killerNumbers[thrower];
            const throwerAdj = getAdjacentNumbers(throwerNum);
            let isThrowerKiller = killerIsKiller[thrower];
            let runningLives = killerLives[thrower];

            for (const dart of darts) {
                if (dart.number === 0 || dart.number === 25) continue;

                const multiplier = getMultiplier(dart.modifier);
                const wasKillerBeforeDart = isThrowerKiller;

                let livesGained = 0;
                if (dart.number === throwerNum) {
                    livesGained = 3 * multiplier;
                    changes.push({ player: thrower, delta: livesGained, reason: 'own' });
                } else if (throwerAdj.includes(dart.number)) {
                    livesGained = 1 * multiplier;
                    changes.push({ player: thrower, delta: livesGained, reason: 'adjacent' });
                }

                runningLives += livesGained;
                if (!isThrowerKiller && runningLives >= 9) {
                    isThrowerKiller = true;
                }

                if (wasKillerBeforeDart) {
                    for (const otherPlayer of players) {
                        if (otherPlayer === thrower || killerEliminated[otherPlayer]) continue;
                        const otherNum = killerNumbers[otherPlayer];
                        const otherAdj = getAdjacentNumbers(otherNum);

                        if (dart.number === otherNum) {
                            changes.push({ player: otherPlayer, delta: -3 * multiplier, reason: 'killed' });
                        } else if (otherAdj.includes(dart.number)) {
                            changes.push({ player: otherPlayer, delta: -1 * multiplier, reason: 'adj-killed' });
                        }
                    }
                }
            }

            return changes;
        }

        function submitKillerTurn() {
            if (killerPhase === 'number') return;
            if (killerDarts.length === 0) return;

            const currentPlayer = players[currentPlayerIndex];

            const snapshot = {
                playerIndex: currentPlayerIndex,
                darts: [...killerDarts],
                livesBefore: { ...killerLives },
                killerBefore: { ...killerIsKiller },
                eliminatedBefore: { ...killerEliminated }
            };

            const changes = processKillerDarts(currentPlayer, killerDarts);

            const aggregated = {};
            for (const c of changes) {
                if (!aggregated[c.player]) aggregated[c.player] = 0;
                aggregated[c.player] += c.delta;
            }

            for (const [player, delta] of Object.entries(aggregated)) {
                killerLives[player] = Math.min(killerLives[player] + delta, 9);
            }

            for (const player of players) {
                if (!killerEliminated[player] && killerLives[player] >= 9) {
                    killerIsKiller[player] = true;
                }
            }

            const newlyEliminated = [];
            for (const player of players) {
                if (!killerEliminated[player] && killerLives[player] <= -1) {
                    killerEliminated[player] = true;
                    newlyEliminated.push(player);
                }
            }

            killerHistory.push(snapshot);

            showKillerTurnSummary(currentPlayer, killerDarts, aggregated, newlyEliminated);
            updateKillerPrevButton();

            const alivePlayers = players.filter(p => !killerEliminated[p]);
            if (alivePlayers.length <= 1) {
                buildKillerScoreboard();
                document.getElementById('killerDartboardSection').classList.add('hidden');
                document.getElementById('killerPrevSection').classList.add('hidden');
                showWinner();
                saveGameState();
                return;
            }

            moveToNextKillerPlayer();
            buildKillerScoreboard();
            updateKillerDisplay();
            saveGameState();
        }

        function showKillerTurnSummary(player, darts, aggregated, newlyEliminated) {
            const container = document.getElementById('killerTurnSummary');
            const dartsText = darts.map(d => d.displayText).join(', ');

            const playerNum = killerNumbers[player];
            let html = `<strong>${player} <span class="killer-number-badge">#${playerNum}</span></strong>: ${dartsText}<br>`;
            for (const [p, delta] of Object.entries(aggregated)) {
                const pNum = killerNumbers[p];
                const cls = delta >= 0 ? 'positive' : 'negative';
                const sign = delta >= 0 ? '+' : '';
                html += `<span class="killer-life-change ${cls}">${p} (#${pNum}): ${sign}${delta}</span> `;
            }
            for (const elim of newlyEliminated) {
                const elimNum = killerNumbers[elim];
                html += `<br><strong style="color:#ff6b6b;">${elim} (#${elimNum}) ${t('eliminatedLabel')}!</strong>`;
            }

            container.innerHTML = html;
            container.classList.remove('hidden');
        }

        function moveToNextKillerPlayer() {
            const totalPlayers = players.length;
            let next = (currentPlayerIndex + 1) % totalPlayers;
            let attempts = 0;
            while (killerEliminated[players[next]] && attempts < totalPlayers) {
                next = (next + 1) % totalPlayers;
                attempts++;
            }
            currentPlayerIndex = next;
        }

        function previousKillerTurn() {
            if (killerHistory.length === 0) return;

            const snapshot = killerHistory.pop();
            currentPlayerIndex = snapshot.playerIndex;
            killerLives = { ...snapshot.livesBefore };
            killerIsKiller = { ...snapshot.killerBefore };
            killerEliminated = { ...snapshot.eliminatedBefore };

            document.getElementById('killerDartboardSection').classList.remove('hidden');
            document.getElementById('killerPrevSection').classList.remove('hidden');
            document.getElementById('winnerSection').style.display = 'none';
            document.getElementById('killerTurnSummary').classList.add('hidden');

            updateKillerDisplay();
            buildKillerScoreboard();
            updateKillerPrevButton();
            saveGameState();
        }

        function updateKillerPrevButton() {
            const btn = document.getElementById('killerPrevBtn');
            btn.style.display = killerHistory.length > 0 ? 'inline-block' : 'none';
        }

        // ==================== CLOCK MODE ====================

        function getClockTargetName(position) {
            if (position <= 10) return String(position);
            return t('clockBull');
        }

        function updateClockDisplay() {
            const currentPlayer = players[currentPlayerIndex];
            const banner = document.getElementById('clockBannerText');
            const sub = document.getElementById('clockBannerSub');
            const extraBadge = document.getElementById('clockExtraTurnBadge');

            extraBadge.classList.add('hidden');

            if (clockFinished[currentPlayer]) {
                banner.textContent = `${currentPlayer} - ${t('clockFinished')}`;
                sub.textContent = '';
            } else {
                const playerTurnNum = clockHistory.filter(h => h.player === currentPlayer).length + 1;
                banner.textContent = `${t('clockTurn')} ${playerTurnNum} ‚Äî ${currentPlayer}${t('playerTurn')}`;
                const targetName = getClockTargetName(clockPosition[currentPlayer]);
                sub.textContent = `${t('clockTarget')} ${targetName}`;
            }

            clearAllClockDarts();
        }

        function buildClockScoreboard() {
            const board = document.getElementById('clockScoreboard');
            board.innerHTML = players.map(player => {
                const pos = clockPosition[player] || 1;
                const finished = clockFinished[player];
                const isCurrent = player === players[currentPlayerIndex];
                const progress = getClockProgress(pos, finished);
                const targetName = finished ? t('clockFinished') : getClockTargetName(pos);

                let classes = 'clock-player-card';
                if (isCurrent && !finished) classes += ' current-turn';
                if (finished) classes += ' finished';

                let finishRank = '';
                if (finished) {
                    const rank = clockFinishOrder.indexOf(player) + 1;
                    if (rank > 0) finishRank = `<div class="clock-finished-badge">#${rank}</div>`;
                }

                return `
                    <div class="${classes}">
                        <div class="player-name">${player}</div>
                        <div class="player-target">${targetName}</div>
                        <div class="clock-progress-bar">
                            <div class="clock-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        ${finishRank}
                    </div>
                `;
            }).join('');
        }

        function buildClockNumberGrid() {
            const grid = document.getElementById('clockNumberGrid');
            const currentPlayer = players[currentPlayerIndex];
            const startPos = clockPosition[currentPlayer] || 1;
            const target = getClockPreviewTarget(clockDarts, startPos);
            const modifiers = document.getElementById('clockModifiers');

            let html = '';
            if (target >= 12) {
                // Player already finished mid-turn - only show miss
                html += `<button class="clock-num-btn miss-btn" onclick="addClockDart(0)">${t('miss')}</button>`;
                modifiers.classList.add('hidden');
            } else if (target > 10) {
                // Target is Bull - show Bull + Miss, hide modifiers
                html += `<button class="clock-num-btn target" onclick="addClockDart(25)">${t('clockBull')}</button>`;
                html += `<button class="clock-num-btn miss-btn" onclick="addClockDart(0)">${t('miss')}</button>`;
                modifiers.classList.add('hidden');
            } else {
                // Target is a number 1-10 - show target + miss, show modifiers
                html += `<button class="clock-num-btn target" onclick="addClockDart(${target})">${target}</button>`;
                html += `<button class="clock-num-btn miss-btn" onclick="addClockDart(0)">${t('miss')}</button>`;
                modifiers.classList.remove('hidden');
            }

            grid.innerHTML = html;
        }

        function setClockModifier(modifier) {
            clockModifier = modifier;
            document.getElementById('clockSingleBtn').classList.remove('active');
            document.getElementById('clockDoubleBtn').classList.remove('active');
            document.getElementById('clockTripleBtn').classList.remove('active');
            document.getElementById('clock' + modifier.charAt(0).toUpperCase() + modifier.slice(1) + 'Btn').classList.add('active');
        }

        function addClockDart(number) {
            if (clockDarts.length >= 3) return;

            let score = number;
            let displayText = '';
            let modifier = clockModifier;

            if (number === 25) {
                if (clockModifier === 'double') {
                    score = 50;
                    displayText = 'Bull√ó2';
                } else {
                    score = 25;
                    displayText = 'Bull';
                    modifier = 'single';
                }
            } else if (number === 0) {
                score = 0;
                displayText = t('miss');
                modifier = 'miss';
            } else {
                if (clockModifier === 'double') {
                    score = number * 2;
                    displayText = `D${number}`;
                } else if (clockModifier === 'triple') {
                    score = number * 3;
                    displayText = `T${number}`;
                } else {
                    score = number;
                    displayText = `${number}`;
                }
            }

            clockDarts.push({ number, modifier, score, displayText });
            updateClockDartsDisplay();
            setClockModifier('single');
            buildClockNumberGrid();
        }

        function clearLastClockDart() {
            if (clockDarts.length > 0) {
                clockDarts.pop();
                updateClockDartsDisplay();
                buildClockNumberGrid();
            }
        }

        function clearAllClockDarts() {
            clockDarts = [];
            clockModifier = 'single';
            setClockModifier('single');
            updateClockDartsDisplay();
            buildClockNumberGrid();
        }

        function updateClockDartsDisplay() {
            for (let i = 1; i <= 3; i++) {
                const slot = document.getElementById(`clockDart${i}`);
                if (clockDarts.length >= i) {
                    slot.textContent = clockDarts[i - 1].displayText;
                    slot.classList.add('filled');
                } else {
                    slot.textContent = '-';
                    slot.classList.remove('filled');
                }
            }
        }

        function submitClockTurn() {
            if (clockDarts.length === 0) return;

            const currentPlayer = players[currentPlayerIndex];
            const startPos = clockPosition[currentPlayer] || 1;
            const result = processClockDarts(clockDarts, startPos);

            // Save history (including turn number for undo)
            clockHistory.push({
                player: currentPlayer,
                prevPos: startPos,
                newPos: result.endPosition,
                darts: [...clockDarts],
                wasFinished: clockFinished[currentPlayer],
                extraTurn: result.extraTurn,
                finishOrderLength: clockFinishOrder.length
            });

            // Apply changes
            clockPosition[currentPlayer] = result.endPosition;

            if (result.finished && !clockFinished[currentPlayer]) {
                clockFinished[currentPlayer] = true;
                clockFinishOrder.push(currentPlayer);
            }

            buildClockScoreboard();

            // First player to finish wins ‚Äî game ends immediately
            if (result.finished) {
                showWinner();
                updateClockPrevButton();
                saveGameState();
                return;
            }

            // Check if all players have completed max turns
            const allPlayersAt10 = players.every(p => {
                return clockFinished[p] || clockHistory.filter(h => h.player === p).length >= CLOCK_MAX_TURNS;
            });
            if (allPlayersAt10) {
                showWinner();
                updateClockPrevButton();
                saveGameState();
                return;
            }

            // Move to next player (or same player if extra turn)
            if (result.extraTurn) {
                // Same player gets another turn
                updateClockDisplay();
                const extraBadge = document.getElementById('clockExtraTurnBadge');
                extraBadge.textContent = `‚ö° ${t('clockExtraTurn')}`;
                extraBadge.classList.remove('hidden');
            } else {
                moveToNextClockPlayer();
            }

            updateClockPrevButton();
            saveGameState();
        }

        function moveToNextClockPlayer() {
            const startIdx = currentPlayerIndex;
            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                const p = players[currentPlayerIndex];
                const playerTurns = clockHistory.filter(h => h.player === p).length;
                if (!clockFinished[p] && playerTurns < CLOCK_MAX_TURNS) {
                    updateClockDisplay();
                    buildClockScoreboard();
                    return;
                }
            } while (currentPlayerIndex !== startIdx);

            // All finished or reached turn limit
            showWinner();
        }

        function previousClockTurn() {
            if (clockHistory.length === 0) return;

            const last = clockHistory.pop();

            // Restore position
            clockPosition[last.player] = last.prevPos;

            // Undo finish if needed
            if (clockFinished[last.player] && !last.wasFinished) {
                clockFinished[last.player] = false;
                clockFinishOrder = clockFinishOrder.filter(p => p !== last.player);
            }

            // Restore player index
            currentPlayerIndex = players.indexOf(last.player);

            // Hide winner if shown
            document.getElementById('winnerSection').style.display = 'none';
            document.getElementById('clockDartboardSection').classList.remove('hidden');
            document.getElementById('clockPrevSection').classList.remove('hidden');

            updateClockDisplay();
            buildClockScoreboard();
            updateClockPrevButton();
            saveGameState();
        }

        function updateClockPrevButton() {
            const btn = document.getElementById('clockPrevBtn');
            btn.style.display = clockHistory.length > 0 ? 'inline-block' : 'none';
        }

        // ==================== COMMON ====================

        function showWinner() {
            // Tournament mode: intercept and handle match result
            if (tournamentMode && tournamentState) {
                handleTournamentMatchEnd();
                return;
            }

            if (gameMode === 'classic') {
                document.getElementById('classicInputSection').classList.add('hidden');
                document.getElementById('editScoresBtn').style.display = 'inline-block';
            } else if (gameMode === 'yahtzee') {
                document.getElementById('yahtzeeInputSection').classList.add('hidden');
                document.getElementById('editScoresBtn').style.display = yahtzeeHistory.length > 0 ? 'inline-block' : 'none';
                scoresHidden = false;
                document.getElementById('hideScoresBtn').textContent = 'üëÅÔ∏è';
                updateScoreVisibility();
            } else if (gameMode === 'killer') {
                document.getElementById('killerDartboardSection').classList.add('hidden');
                document.getElementById('killerPrevSection').classList.add('hidden');
                document.getElementById('editScoresBtn').style.display = killerHistory.length > 0 ? 'inline-block' : 'none';
            } else if (gameMode === 'clock') {
                document.getElementById('clockDartboardSection').classList.add('hidden');
                document.getElementById('clockPrevSection').classList.add('hidden');
                document.getElementById('editScoresBtn').style.display = clockHistory.length > 0 ? 'inline-block' : 'none';
            }

            const winnerSection = document.getElementById('winnerSection');
            winnerSection.style.display = 'block';

            if (gameMode === 'killer') {
                const alivePlayers = players.filter(p => !killerEliminated[p]);
                const winnerName = alivePlayers.length === 1 ? alivePlayers[0] : players[0];
                document.getElementById('winnerName').textContent = `üéâ ${winnerName} ${t('wins')} üéâ`;
                document.getElementById('winnerScore').textContent = `${killerLives[winnerName]} ${t('lives')}`;
            } else if (gameMode === 'clock') {
                const result = determineClockWinner(players, clockPosition, clockFinishOrder);
                if (!result.isTie) {
                    const winnerName = result.winners[0];
                    const winnerTurns = clockHistory.filter(h => h.player === winnerName).length;
                    document.getElementById('winnerName').textContent = `üéâ ${winnerName} ${t('wins')} üéâ`;
                    if (clockFinishOrder.length > 0) {
                        document.getElementById('winnerScore').textContent = `${t('clockTurn')} ${winnerTurns}`;
                    } else {
                        const targetName = getClockTargetName(clockPosition[winnerName] || 1);
                        document.getElementById('winnerScore').textContent = `${t('clockTarget')} ${targetName}`;
                    }
                } else {
                    const highPos = clockPosition[result.winners[0]] || 1;
                    const targetName = getClockTargetName(highPos);
                    document.getElementById('winnerName').textContent = t('itsATie');
                    document.getElementById('winnerScore').textContent = `${result.winners.join(' & ')} ‚Äî ${t('clockTarget')} ${targetName}`;
                }
            } else {
                let highScore = -Infinity;
                players.forEach(player => {
                    const playerScore = gameMode === 'classic' ? scores[player].capital : scores[player].total;
                    if (playerScore > highScore) {
                        highScore = playerScore;
                    }
                });

                const winners = players.filter(p => {
                    const s = gameMode === 'classic' ? scores[p].capital : scores[p].total;
                    return s === highScore;
                });

                if (winners.length > 1) {
                    document.getElementById('winnerName').textContent = t('itsATie');
                    document.getElementById('winnerScore').textContent = `${winners.join(' & ')} ${t('tiedWith')} ${highScore} ${t('points')}!`;
                } else {
                    document.getElementById('winnerName').textContent = `üéâ ${winners[0]} ${t('wins')} üéâ`;
                    document.getElementById('winnerScore').textContent = `${t('finalScore')} ${highScore} ${t('points')}`;
                }
            }
        }

        function resetGame() {
            // In tournament mode, cancel the in-progress match and go back to bracket
            if (tournamentMode && tournamentState) {
                const confirmMsg = {
                    'en': 'Cancel this match and return to the tournament bracket?',
                    'fr': 'Annuler ce match et revenir au tableau du tournoi ?',
                    'es': '¬øCancelar este partido y volver al cuadro del torneo?'
                };
                if (!confirm(confirmMsg[currentLang])) return;

                // Remove the incomplete match so the players become available again
                const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
                if (currentRoundData) {
                    const incompleteIdx = currentRoundData.matches.findIndex(m => !m.completed);
                    if (incompleteIdx >= 0) {
                        currentRoundData.matches.splice(incompleteIdx, 1);
                    }
                }

                returnToTournament();
                return;
            }

            const confirmMessage = {
                'en': 'Are you sure you want to reset the game? All progress will be lost.',
                'fr': '√ätes-vous s√ªr de vouloir recommencer ? Toute la progression sera perdue.',
                'es': '¬øEst√°s seguro de que quieres reiniciar el juego? Se perder√° todo el progreso.'
            };

            if (!confirm(confirmMessage[currentLang])) {
                return;
            }

            currentRound = 0;
            currentPlayerIndex = 0;
            scores = {};
            scoresHidden = false;
            selectedContract = null;
            selectedScratch = null;
            isScratchMode = false;
            yahtzeeHistory = [];
            storedDarts = {};

            killerNumbers = {};
            killerLives = {};
            killerIsKiller = {};
            killerEliminated = {};
            killerPhase = 'number';
            killerHistory = [];
            killerDarts = [];
            killerModifier = 'single';

            clockPosition = {};
            clockFinished = {};
            clockHistory = [];
            clockDarts = [];
            clockModifier = 'single';
            clockFinishOrder = [];

            // Reset dart input state
            currentDarts = [];
            currentModifier = 'single';
            dartInputTargetField = null;

            // Close dart input modal if open
            document.getElementById('dartInputModal').classList.remove('active');

            // Reset winner section button visibility
            document.getElementById('playAgainBtn').style.display = '';
            document.getElementById('backToTournamentBtn').classList.add('hidden');
            document.getElementById('backToTournamentBtn').style.display = 'none';
            document.getElementById('tieResolutionUI').classList.add('hidden');

            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('winnerSection').style.display = 'none';
            hideAllModeSections();
            document.getElementById('classicInputSection').classList.remove('hidden');

            updatePlayerList();
            clearGameState();
        }

        // ==================== TOURNAMENT MODE ====================

        function toggleTournamentMode() {
            tournamentMode = document.getElementById('tournamentCheckbox').checked;
            const startBtn = document.getElementById('startBtn');
            if (tournamentMode) {
                startBtn.setAttribute('data-i18n', 'startTournament');
                startBtn.textContent = t('startTournament');
                document.getElementById('modeDescription').textContent = t('tournamentDesc');
            } else {
                startBtn.setAttribute('data-i18n', 'startGame');
                startBtn.textContent = t('startGame');
                updateModeDescription();
            }
            updatePlayerList();
            saveGameState();
        }

        function startTournament() {
            if (players.length < 3) {
                alert(t('minPlayersTourn'));
                return;
            }
            const selectedMode = document.querySelector('input[name="gameMode"]:checked').value;
            tournamentState = {
                gameType: selectedMode,
                registrants: [...players],
                rounds: [{
                    roundNumber: 1,
                    matches: []
                }],
                currentRound: 0,
                champion: null,
                withdrawn: [],
                lateEntries: {}
            };
            gameMode = selectedMode;

            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('tournamentHub').classList.remove('hidden');
            tournamentSelectedPlayers = [];
            buildBracket();
            buildPlayerRoster();
            buildMatchPicker();
            saveGameState();
        }

        function getTournamentRoundName(roundIndex, totalRounds) {
            const remaining = totalRounds - roundIndex;
            if (remaining === 1) return t('final');
            if (remaining === 2) return t('semiFinals');
            if (remaining === 3) return t('quarterFinals');
            return `${t('roundN')} ${roundIndex + 1}`;
        }

        function estimateTotalRounds(numPlayers) {
            return Math.ceil(Math.log2(Math.max(numPlayers, 2)));
        }

        function buildBracket() {
            const container = document.getElementById('bracketContainer');
            container.innerHTML = '';

            if (!tournamentState) return;

            const totalRounds = estimateTotalRounds(tournamentState.registrants.length);

            // Render existing rounds
            tournamentState.rounds.forEach((round, idx) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round';

                const title = document.createElement('div');
                title.className = 'bracket-round-title';
                title.textContent = getTournamentRoundName(idx, totalRounds);
                roundDiv.appendChild(title);

                if (round.matches.length === 0 && idx === tournamentState.currentRound) {
                    const empty = document.createElement('div');
                    empty.className = 'bracket-match-empty';
                    empty.textContent = '...';
                    roundDiv.appendChild(empty);
                }

                round.matches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'bracket-match';
                    if (match.completed) {
                        matchDiv.classList.add('completed');
                    }
                    if (match.isBye) {
                        matchDiv.classList.add('bye');
                    }

                    match.players.forEach((player, pIdx) => {
                        if (pIdx > 0) {
                            const vs = document.createElement('div');
                            vs.className = 'bracket-match-vs';
                            vs.textContent = match.isBye ? '' : t('matchVs');
                            matchDiv.appendChild(vs);
                        }
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'bracket-match-player';
                        if (match.completed && match.winner === player) {
                            playerDiv.classList.add('winner');
                        } else if (match.completed && match.winner !== player) {
                            playerDiv.classList.add('loser');
                        }

                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = player;
                        playerDiv.appendChild(nameSpan);

                        if (match.completed && match.scores && match.scores[player] !== undefined) {
                            const scoreSpan = document.createElement('span');
                            scoreSpan.style.fontSize = '0.85em';
                            scoreSpan.style.color = '#f9d423';
                            scoreSpan.textContent = match.scores[player];
                            playerDiv.appendChild(scoreSpan);
                        }

                        matchDiv.appendChild(playerDiv);
                    });

                    if (match.isBye) {
                        const byeDiv = document.createElement('div');
                        byeDiv.className = 'bracket-match-vs';
                        byeDiv.textContent = `(${t('bye')})`;
                        matchDiv.appendChild(byeDiv);
                    }

                    container.appendChild(matchDiv);
                    roundDiv.appendChild(matchDiv);
                });

                container.appendChild(roundDiv);
            });

            // Show placeholder columns for future rounds
            for (let i = tournamentState.rounds.length; i < totalRounds; i++) {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round';

                const title = document.createElement('div');
                title.className = 'bracket-round-title';
                title.textContent = getTournamentRoundName(i, totalRounds);
                roundDiv.appendChild(title);

                const empty = document.createElement('div');
                empty.className = 'bracket-match-empty';
                empty.textContent = '...';
                roundDiv.appendChild(empty);

                container.appendChild(roundDiv);
            }
        }

        function getAvailablePlayers() {
            if (!tournamentState) return [];

            const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
            if (!currentRoundData) return [];

            const withdrawn = new Set(tournamentState.withdrawn || []);
            const matched = new Set(currentRoundData.matches.flatMap(m => m.players));

            if (tournamentState.currentRound === 0) {
                // Round 1: all registrants not yet in a match and not withdrawn
                return tournamentState.registrants.filter(p => !matched.has(p) && !withdrawn.has(p));
            } else {
                // Subsequent rounds: winners of previous round not yet in a match and not withdrawn
                const prevRound = tournamentState.rounds[tournamentState.currentRound - 1];
                const prevWinners = prevRound.matches.map(m => m.winner).filter(Boolean);
                const pool = prevWinners.filter(p => !matched.has(p) && !withdrawn.has(p));

                // Include late entries added during or for this round
                const lateEntries = tournamentState.lateEntries || {};
                for (const [player, joinedRound] of Object.entries(lateEntries)) {
                    if (joinedRound === tournamentState.currentRound &&
                        !matched.has(player) && !withdrawn.has(player) && !pool.includes(player)) {
                        pool.push(player);
                    }
                }

                return pool;
            }
        }

        function addTournamentPlayer() {
            const input = document.getElementById('tournamentAddPlayerInput');
            const name = input.value.trim();
            if (!name) return;

            if (tournamentState.registrants.includes(name)) {
                alert(t('playerAlreadyExists'));
                return;
            }

            // Add to registrants
            tournamentState.registrants.push(name);

            if (!tournamentState.withdrawn) {
                tournamentState.withdrawn = [];
            }

            // Track late entries so they appear in the available pool for non-first rounds
            if (!tournamentState.lateEntries) {
                tournamentState.lateEntries = {};
            }
            if (tournamentState.currentRound > 0) {
                tournamentState.lateEntries[name] = tournamentState.currentRound;
            }

            input.value = '';
            saveGameState();
            buildBracket();
            buildPlayerRoster();
            buildMatchPicker();
        }

        function removeTournamentPlayer(name) {
            if (!tournamentState) return;

            // Initialize withdrawn list if needed
            if (!tournamentState.withdrawn) {
                tournamentState.withdrawn = [];
            }

            // Check if already withdrawn
            if (tournamentState.withdrawn.includes(name)) return;

            // Check if player is in an in-progress match (not yet completed)
            const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
            if (currentRoundData) {
                const inProgressMatch = currentRoundData.matches.find(
                    m => !m.completed && m.players.includes(name)
                );
                if (inProgressMatch) {
                    alert(t('cannotRemoveInMatch'));
                    return;
                }
            }

            // Mark as withdrawn
            tournamentState.withdrawn.push(name);

            // If they were in the available pool for the current round, give their
            // pending opponent(s) a bye by simply removing this player from future matching.
            // The checkRoundComplete logic will handle byes when pool shrinks.

            saveGameState();
            buildBracket();
            buildPlayerRoster();
            buildMatchPicker();
        }

        function buildPlayerRoster() {
            const mgmt = document.getElementById('tournamentPlayerMgmt');
            if (mgmt) mgmt.style.display = '';
            const roster = document.getElementById('tournamentPlayerRoster');
            if (!roster || !tournamentState) return;
            roster.innerHTML = '';

            const withdrawn = tournamentState.withdrawn || [];
            const available = getAvailablePlayers();
            const eliminated = getEliminatedPlayers();

            tournamentState.registrants.forEach(name => {
                const tag = document.createElement('div');
                tag.className = 'tournament-roster-player';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                tag.appendChild(nameSpan);

                if (withdrawn.includes(name)) {
                    tag.classList.add('withdrawn');
                    const label = document.createElement('span');
                    label.textContent = ` (${t('withdrawn')})`;
                    label.style.fontSize = '0.8em';
                    tag.appendChild(label);
                } else if (eliminated.includes(name)) {
                    tag.classList.add('eliminated');
                } else if (available.includes(name)) {
                    // Can be removed ‚Äî show remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'tournament-roster-remove';
                    removeBtn.textContent = '‚úï';
                    removeBtn.title = t('removePlayer');
                    removeBtn.onclick = () => {
                        const msg = {
                            'en': `Remove ${name} from the tournament?`,
                            'fr': `Retirer ${name} du tournoi ?`,
                            'es': `¬øEliminar a ${name} del torneo?`
                        };
                        if (confirm(msg[currentLang])) {
                            removeTournamentPlayer(name);
                        }
                    };
                    tag.appendChild(removeBtn);
                }

                roster.appendChild(tag);
            });
        }

        function getEliminatedPlayers() {
            if (!tournamentState) return [];
            const withdrawn = tournamentState.withdrawn || [];
            const eliminated = [];

            // A player is eliminated if they lost a match (were in a completed match but are not the winner)
            tournamentState.rounds.forEach(round => {
                round.matches.forEach(match => {
                    if (match.completed && !match.isBye) {
                        match.players.forEach(p => {
                            if (p !== match.winner && !withdrawn.includes(p)) {
                                eliminated.push(p);
                            }
                        });
                    }
                });
            });
            return eliminated;
        }

        function buildMatchPicker() {
            const picker = document.getElementById('matchPicker');
            const pool = getAvailablePlayers();
            const availableDiv = document.getElementById('availablePlayers');
            const startMatchBtn = document.getElementById('startMatchBtn');

            // If champion is determined, hide picker
            if (tournamentState && tournamentState.champion) {
                picker.classList.add('hidden');
                return;
            }

            if (pool.length < 2) {
                // Check if round needs advancing
                checkRoundComplete();
                const newPool = getAvailablePlayers();
                if (newPool.length < 2) {
                    picker.classList.add('hidden');
                    return;
                }
                // Re-run with new pool after round advance
                buildMatchPicker();
                return;
            }

            picker.classList.remove('hidden');
            tournamentSelectedPlayers = [];
            availableDiv.innerHTML = '';

            pool.forEach(player => {
                const btn = document.createElement('button');
                btn.className = 'match-picker-player';
                btn.textContent = player;
                btn.onclick = () => toggleMatchPlayerSelection(player, btn);
                availableDiv.appendChild(btn);
            });

            startMatchBtn.disabled = true;
        }

        function toggleMatchPlayerSelection(player, btn) {
            const idx = tournamentSelectedPlayers.indexOf(player);
            if (idx >= 0) {
                tournamentSelectedPlayers.splice(idx, 1);
                btn.classList.remove('selected');
            } else {
                tournamentSelectedPlayers.push(player);
                btn.classList.add('selected');
            }
            document.getElementById('startMatchBtn').disabled = tournamentSelectedPlayers.length < 2;
        }

        function startTournamentMatch() {
            if (tournamentSelectedPlayers.length < 2) return;

            // Record the match as in-progress
            const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
            currentRoundData.matches.push({
                players: [...tournamentSelectedPlayers],
                winner: null,
                scores: null,
                completed: false,
                isBye: false
            });

            // Set up the game with selected players
            players = [...tournamentSelectedPlayers];
            gameMode = tournamentState.gameType;

            // Programmatically check the right radio button
            const radio = document.querySelector(`input[name="gameMode"][value="${gameMode}"]`);
            if (radio) radio.checked = true;

            // Hide tournament hub, show setup momentarily (startGame hides it)
            document.getElementById('tournamentHub').classList.add('hidden');
            document.getElementById('setupSection').classList.remove('hidden');

            // Start the game
            startGame();
            saveGameState();
        }

        function getMatchWinners() {
            // Determine match winner(s) based on game mode
            if (gameMode === 'killer') {
                const alivePlayers = players.filter(p => !killerEliminated[p]);
                return alivePlayers.length >= 1 ? [alivePlayers[0]] : [players[0]];
            } else if (gameMode === 'clock') {
                const result = determineClockWinner(players, clockPosition, clockFinishOrder);
                return result.winners;
            } else {
                // Classic or Yahtzee
                let highScore = -Infinity;
                players.forEach(player => {
                    const playerScore = gameMode === 'classic' ? scores[player].capital : scores[player].total;
                    if (playerScore > highScore) {
                        highScore = playerScore;
                    }
                });
                return players.filter(p => {
                    const s = gameMode === 'classic' ? scores[p].capital : scores[p].total;
                    return s === highScore;
                });
            }
        }

        function getMatchScores() {
            // Extract scores for display in bracket
            const matchScores = {};
            players.forEach(player => {
                if (gameMode === 'classic') {
                    matchScores[player] = scores[player] ? scores[player].capital : 0;
                } else if (gameMode === 'yahtzee') {
                    matchScores[player] = scores[player] ? scores[player].total : 0;
                } else if (gameMode === 'killer') {
                    matchScores[player] = killerLives[player] || 0;
                } else if (gameMode === 'clock') {
                    if (clockFinished[player]) {
                        matchScores[player] = t('clockFinished');
                    } else {
                        matchScores[player] = getClockTargetName(clockPosition[player] || 1);
                    }
                }
            });
            return matchScores;
        }

        function handleTournamentMatchEnd() {
            // Hide mode-specific input sections
            if (gameMode === 'classic') {
                document.getElementById('classicInputSection').classList.add('hidden');
            } else if (gameMode === 'yahtzee') {
                document.getElementById('yahtzeeInputSection').classList.add('hidden');
                scoresHidden = false;
                document.getElementById('hideScoresBtn').textContent = 'üëÅÔ∏è';
                updateScoreVisibility();
            } else if (gameMode === 'killer') {
                document.getElementById('killerDartboardSection').classList.add('hidden');
                document.getElementById('killerPrevSection').classList.add('hidden');
            } else if (gameMode === 'clock') {
                document.getElementById('clockDartboardSection').classList.add('hidden');
                document.getElementById('clockPrevSection').classList.add('hidden');
            }

            const winnerSection = document.getElementById('winnerSection');
            winnerSection.style.display = 'block';

            const matchWinners = getMatchWinners();
            const matchScores = getMatchScores();

            // Hide normal buttons, show tournament button
            document.getElementById('editScoresBtn').style.display = 'none';
            document.getElementById('playAgainBtn').style.display = 'none';
            document.getElementById('backToTournamentBtn').classList.remove('hidden');
            document.getElementById('backToTournamentBtn').style.display = 'inline-block';

            if (matchWinners.length === 1) {
                // Clear winner
                const winner = matchWinners[0];
                document.getElementById('winnerName').textContent = `üéâ ${winner} ${t('wins')} üéâ`;

                const scoreStr = matchScores[winner] !== undefined ? matchScores[winner] : '';
                document.getElementById('winnerScore').textContent = scoreStr !== '' ? `${t('matchScore')}: ${scoreStr}` : '';

                recordMatchResult(winner, matchScores);
                document.getElementById('tieResolutionUI').classList.add('hidden');
            } else {
                // Tie - show manual resolution
                document.getElementById('winnerName').textContent = t('itsATie');
                document.getElementById('winnerScore').textContent = matchWinners.join(' & ');
                document.getElementById('backToTournamentBtn').style.display = 'none';

                showTieResolution(matchWinners, matchScores);
            }

            saveGameState();
        }

        function showTieResolution(tiedPlayers, matchScores) {
            const tieUI = document.getElementById('tieResolutionUI');
            const buttonsDiv = document.getElementById('tiePlayerButtons');
            tieUI.classList.remove('hidden');
            buttonsDiv.innerHTML = '';

            tiedPlayers.forEach(player => {
                const btn = document.createElement('button');
                btn.className = 'tie-resolution-btn';
                btn.textContent = player;
                btn.onclick = () => {
                    recordMatchResult(player, matchScores);
                    tieUI.classList.add('hidden');
                    document.getElementById('winnerName').textContent = `üéâ ${player} ${t('wins')} üéâ`;
                    document.getElementById('backToTournamentBtn').style.display = 'inline-block';
                    saveGameState();
                };
                buttonsDiv.appendChild(btn);
            });
        }

        function recordMatchResult(winner, matchScores) {
            if (!tournamentState) return;

            const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
            // Find the latest incomplete match
            const match = currentRoundData.matches.find(m => !m.completed);
            if (!match) return;

            match.winner = winner;
            match.scores = matchScores || {};
            match.completed = true;
            saveGameState();
        }

        function returnToTournament() {
            // Hide game board and winner section
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('winnerSection').style.display = 'none';

            // Reset tournament button visibility for next time
            document.getElementById('backToTournamentBtn').classList.add('hidden');
            document.getElementById('backToTournamentBtn').style.display = 'none';
            document.getElementById('playAgainBtn').style.display = '';
            document.getElementById('tieResolutionUI').classList.add('hidden');

            // Reset game state
            currentRound = 0;
            currentPlayerIndex = 0;
            scores = {};
            scoresHidden = false;
            selectedContract = null;
            selectedScratch = null;
            isScratchMode = false;
            yahtzeeHistory = [];
            storedDarts = {};
            killerNumbers = {};
            killerLives = {};
            killerIsKiller = {};
            killerEliminated = {};
            killerPhase = 'number';
            killerHistory = [];
            killerDarts = [];
            killerModifier = 'single';
            clockPosition = {};
            clockFinished = {};
            clockHistory = [];
            clockDarts = [];
            clockModifier = 'single';
            clockFinishOrder = [];

            // Reset dart input state
            currentDarts = [];
            currentModifier = 'single';
            dartInputTargetField = null;

            // Close dart input modal if open
            document.getElementById('dartInputModal').classList.remove('active');

            hideAllModeSections();

            // Check round completion and advance if needed
            checkRoundComplete();

            // Show tournament hub
            document.getElementById('tournamentHub').classList.remove('hidden');

            // Check if champion was determined
            if (tournamentState && tournamentState.champion) {
                showTournamentChampion();
            } else {
                buildBracket();
                buildPlayerRoster();
                buildMatchPicker();
            }

            saveGameState();
        }

        function checkRoundComplete() {
            if (!tournamentState) return;

            const available = getAvailablePlayers();
            const currentRoundData = tournamentState.rounds[tournamentState.currentRound];
            if (!currentRoundData) return;

            const allMatchesDone = currentRoundData.matches.length > 0 &&
                currentRoundData.matches.every(m => m.completed);

            if (allMatchesDone && available.length <= 1) {
                const winners = currentRoundData.matches.map(m => m.winner).filter(Boolean);

                // If 1 unmatched player, they auto-advance (bye)
                if (available.length === 1) {
                    const byePlayer = available[0];
                    currentRoundData.matches.push({
                        players: [byePlayer],
                        winner: byePlayer,
                        scores: {},
                        completed: true,
                        isBye: true
                    });
                    winners.push(byePlayer);
                }

                if (winners.length <= 1) {
                    // Tournament complete
                    tournamentState.champion = winners[0] || null;
                } else {
                    // Create next round
                    tournamentState.currentRound++;
                    tournamentState.rounds.push({
                        roundNumber: tournamentState.currentRound + 1,
                        matches: []
                    });
                }
            }
        }

        function showTournamentChampion() {
            if (!tournamentState || !tournamentState.champion) return;

            const championSection = document.getElementById('tournamentChampionSection');
            const matchPicker = document.getElementById('matchPicker');

            document.getElementById('championName').textContent = `üéâ ${tournamentState.champion} üéâ`;
            championSection.classList.remove('hidden');
            matchPicker.classList.add('hidden');
            document.getElementById('tournamentPlayerMgmt').style.display = 'none';
            document.getElementById('newTournamentBtn').classList.remove('hidden');

            buildBracket();
        }

        function exitTournament() {
            const confirmMsg = {
                'en': 'Exit tournament? All tournament progress will be lost.',
                'fr': 'Quitter le tournoi ? Toute la progression sera perdue.',
                'es': '¬øSalir del torneo? Se perder√° todo el progreso.'
            };

            if (!confirm(confirmMsg[currentLang])) return;

            tournamentMode = false;
            tournamentState = null;
            tournamentSelectedPlayers = [];

            document.getElementById('tournamentHub').classList.add('hidden');
            document.getElementById('tournamentChampionSection').classList.add('hidden');
            document.getElementById('newTournamentBtn').classList.add('hidden');
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('winnerSection').style.display = 'none';
            document.getElementById('setupSection').classList.remove('hidden');

            // Reset tournament checkbox
            document.getElementById('tournamentCheckbox').checked = false;
            const startBtn = document.getElementById('startBtn');
            startBtn.setAttribute('data-i18n', 'startGame');
            startBtn.textContent = t('startGame');

            players = [];
            updatePlayerList();
            clearGameState();
        }

        function newTournament() {
            tournamentState = null;
            tournamentSelectedPlayers = [];

            document.getElementById('tournamentHub').classList.add('hidden');
            document.getElementById('tournamentChampionSection').classList.add('hidden');
            document.getElementById('newTournamentBtn').classList.add('hidden');
            document.getElementById('setupSection').classList.remove('hidden');

            updatePlayerList();
            clearGameState();
        }

        // ==================== DART INPUT ====================

        function openDartInput(inputFieldId) {
            dartInputTargetField = inputFieldId;
            currentDarts = [];
            currentModifier = 'single';
            updateDartDisplay();
            setModifier('single');
            document.getElementById('dartInputModal').classList.add('active');
        }

        function openDartInputClassic(inputFieldId) {
            dartInputTargetField = inputFieldId;
            // Load existing darts if any
            currentDarts = storedDarts[inputFieldId] ? [...storedDarts[inputFieldId]] : [];
            currentModifier = 'single';
            updateDartDisplay();
            setModifier('single');
            document.getElementById('dartInputModal').classList.add('active');
        }

        function openDartInputYahtzee() {
            dartInputTargetField = 'yahtzeeCurrentDarts';
            // Load existing darts if any
            currentDarts = storedDarts['yahtzeeCurrentDarts'] ? [...storedDarts['yahtzeeCurrentDarts']] : [];
            currentModifier = 'single';
            updateDartDisplay();
            setModifier('single');
            document.getElementById('dartInputModal').classList.add('active');
        }

        function closeDartInput() {
            document.getElementById('dartInputModal').classList.remove('active');
            dartInputTargetField = null;
        }

        function setModifier(modifier) {
            currentModifier = modifier;
            document.getElementById('singleBtn').classList.remove('active');
            document.getElementById('doubleBtn').classList.remove('active');
            document.getElementById('tripleBtn').classList.remove('active');
            document.getElementById(modifier + 'Btn').classList.add('active');
        }

        function addDart(number) {
            if (currentDarts.length >= 3) return;

            let score = number;
            let displayText = '';
            let modifier = currentModifier;

            if (number === 25) {
                // Bullseye: single=25, double=50
                if (currentModifier === 'double') {
                    score = 50;
                    displayText = 'Bull√ó2';
                } else {
                    score = 25;
                    displayText = 'Bull';
                    modifier = 'single';
                }
            } else if (number === 0) {
                score = 0;
                displayText = 'Miss';
                modifier = 'miss';
            } else {
                if (currentModifier === 'double') {
                    score = number * 2;
                    displayText = `D${number}`;
                } else if (currentModifier === 'triple') {
                    score = number * 3;
                    displayText = `T${number}`;
                } else {
                    score = number;
                    displayText = `${number}`;
                }
            }

            currentDarts.push({ number, modifier, score, displayText });
            updateDartDisplay();

            // Reset to single after each dart
            setModifier('single');
        }

        function clearLastDart() {
            if (currentDarts.length > 0) {
                currentDarts.pop();
                updateDartDisplay();
            }
        }

        function clearAllDarts() {
            currentDarts = [];
            updateDartDisplay();
        }

        function updateDartDisplay() {
            const dart1 = document.getElementById('dart1Display');
            const dart2 = document.getElementById('dart2Display');
            const dart3 = document.getElementById('dart3Display');
            const totalDisplay = document.getElementById('dartTotalDisplay');

            // Update dart 1
            if (currentDarts.length >= 1) {
                dart1.textContent = currentDarts[0].displayText;
                dart1.classList.remove('empty');
            } else {
                dart1.textContent = '-';
                dart1.classList.add('empty');
            }

            // Update dart 2
            if (currentDarts.length >= 2) {
                dart2.textContent = currentDarts[1].displayText;
                dart2.classList.remove('empty');
            } else {
                dart2.textContent = '-';
                dart2.classList.add('empty');
            }

            // Update dart 3
            if (currentDarts.length >= 3) {
                dart3.textContent = currentDarts[2].displayText;
                dart3.classList.remove('empty');
            } else {
                dart3.textContent = '-';
                dart3.classList.add('empty');
            }

            // Calculate and update total
            const total = currentDarts.reduce((sum, dart) => sum + dart.score, 0);
            totalDisplay.textContent = total;
        }

        function confirmDarts() {
            const total = currentDarts.reduce((sum, dart) => sum + dart.score, 0);
            if (dartInputTargetField) {
                // Store the darts for this input field
                storedDarts[dartInputTargetField] = [...currentDarts];

                // Update the input value if it exists
                const inputField = document.getElementById(dartInputTargetField);
                if (inputField) {
                    inputField.value = total;
                }

                // Rebuild score inputs if in Classic mode
                if (gameMode === 'classic' && document.getElementById('classicInputSection').classList.contains('hidden') === false) {
                    buildScoreInputs();
                }

                // Update Yahtzee darts display and highlight valid contracts
                if (gameMode === 'yahtzee' && dartInputTargetField === 'yahtzeeCurrentDarts') {
                    updateYahtzeeDartsDisplay();
                    buildContractSelectors();
                }
            }
            closeDartInput();
        }

        function updateYahtzeeDartsDisplay() {
            const display = document.getElementById('yahtzeeDartsDisplay');
            const darts = storedDarts['yahtzeeCurrentDarts'];

            if (darts && darts.length > 0) {
                const dartsText = darts.map(d => d.displayText).join(', ');
                const total = darts.reduce((sum, d) => sum + d.score, 0);
                display.innerHTML = `<div style="color: #00b894; font-weight: bold;">${dartsText}</div><div style="color: #f9d423; margin-top: 5px;">Total: ${total}</div>`;
            } else {
                display.innerHTML = '<span style="color: #636e72;">No darts entered</span>';
            }
        }

        // ==================== DART ANALYSIS ====================

        // For Classic mode: Calculate score for hitting a specific number
        function calculateClassicScore(darts, targetNumber) {
            if (!darts || darts.length === 0) return 0;

            let score = 0;
            for (let dart of darts) {
                if (dart.number === targetNumber) {
                    score += dart.score;
                }
            }
            return score;
        }

        // ==================== SCORE VALIDATION ====================

        function getValidationRule(contractId) {
            const rules = {
                'en': {
                    'capital': { validate: () => true, message: '' },
                    '20': { validate: (score) => score === 0 || score % 20 === 0, message: '0 or a multiple of 20 (20, 40, 60)' },
                    'side': { validate: () => true, message: '' },
                    '19': { validate: (score) => score === 0 || score % 19 === 0, message: '0 or a multiple of 19 (19, 38, 57)' },
                    '3row': { validate: () => true, message: '' },
                    '18': { validate: (score) => score === 0 || score % 18 === 0, message: '0 or a multiple of 18 (18, 36, 54)' },
                    'color': { validate: () => true, message: '' },
                    '17': { validate: (score) => score === 0 || score % 17 === 0, message: '0 or a multiple of 17 (17, 34, 51)' },
                    'double': { validate: (score) => score === 0 || score % 2 === 0, message: '0 or an even number (any double)' },
                    '16': { validate: (score) => score === 0 || score % 16 === 0, message: '0 or a multiple of 16 (16, 32, 48)' },
                    'triple': { validate: () => true, message: '' },
                    '15': { validate: (score) => score === 0 || score % 15 === 0, message: '0 or a multiple of 15 (15, 30, 45)' },
                    '57': { validate: (score) => score === 0 || score === 57, message: '0 or exactly 57' },
                    '14': { validate: (score) => score === 0 || score % 14 === 0, message: '0 or a multiple of 14 (14, 28, 42)' },
                    'bull': { validate: (score) => score === 0 || score === 25 || score === 50, message: '0, 25, or 50' }
                },
                'fr': {
                    'capital': { validate: () => true, message: '' },
                    '20': { validate: (score) => score === 0 || score % 20 === 0, message: '0 ou un multiple de 20 (20, 40, 60)' },
                    'side': { validate: () => true, message: '' },
                    '19': { validate: (score) => score === 0 || score % 19 === 0, message: '0 ou un multiple de 19 (19, 38, 57)' },
                    '3row': { validate: () => true, message: '' },
                    '18': { validate: (score) => score === 0 || score % 18 === 0, message: '0 ou un multiple de 18 (18, 36, 54)' },
                    'color': { validate: () => true, message: '' },
                    '17': { validate: (score) => score === 0 || score % 17 === 0, message: '0 ou un multiple de 17 (17, 34, 51)' },
                    'double': { validate: (score) => score === 0 || score % 2 === 0, message: '0 ou un nombre pair (n\'importe quel double)' },
                    '16': { validate: (score) => score === 0 || score % 16 === 0, message: '0 ou un multiple de 16 (16, 32, 48)' },
                    'triple': { validate: () => true, message: '' },
                    '15': { validate: (score) => score === 0 || score % 15 === 0, message: '0 ou un multiple de 15 (15, 30, 45)' },
                    '57': { validate: (score) => score === 0 || score === 57, message: '0 ou exactement 57' },
                    '14': { validate: (score) => score === 0 || score % 14 === 0, message: '0 ou un multiple de 14 (14, 28, 42)' },
                    'bull': { validate: (score) => score === 0 || score === 25 || score === 50, message: '0, 25 ou 50' }
                },
                'es': {
                    'capital': { validate: () => true, message: '' },
                    '20': { validate: (score) => score === 0 || score % 20 === 0, message: '0 o un m√∫ltiplo de 20 (20, 40, 60)' },
                    'side': { validate: () => true, message: '' },
                    '19': { validate: (score) => score === 0 || score % 19 === 0, message: '0 o un m√∫ltiplo de 19 (19, 38, 57)' },
                    '3row': { validate: () => true, message: '' },
                    '18': { validate: (score) => score === 0 || score % 18 === 0, message: '0 o un m√∫ltiplo de 18 (18, 36, 54)' },
                    'color': { validate: () => true, message: '' },
                    '17': { validate: (score) => score === 0 || score % 17 === 0, message: '0 o un m√∫ltiplo de 17 (17, 34, 51)' },
                    'double': { validate: (score) => score === 0 || score % 2 === 0, message: '0 o un n√∫mero par (cualquier doble)' },
                    '16': { validate: (score) => score === 0 || score % 16 === 0, message: '0 o un m√∫ltiplo de 16 (16, 32, 48)' },
                    'triple': { validate: () => true, message: '' },
                    '15': { validate: (score) => score === 0 || score % 15 === 0, message: '0 o un m√∫ltiplo de 15 (15, 30, 45)' },
                    '57': { validate: (score) => score === 0 || score === 57, message: '0 o exactamente 57' },
                    '14': { validate: (score) => score === 0 || score % 14 === 0, message: '0 o un m√∫ltiplo de 14 (14, 28, 42)' },
                    'bull': { validate: (score) => score === 0 || score === 25 || score === 50, message: '0, 25 o 50' }
                }
            };

            return rules[currentLang][contractId] || { validate: () => true, message: '' };
        }

        function validateScore(score, contractId) {
            const rule = getValidationRule(contractId);
            return rule.validate(score);
        }

        function showValidationError(contractId) {
            const rule = getValidationRule(contractId);
            const contractName = getContractName(contractId);
            const message = t('invalidScoreDetail')
                .replace('{contract}', contractName)
                .replace('{rule}', rule.message);
            alert(message);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            applyTranslations();
            buildRulesGrid();

            // Try to load saved game state
            const loaded = loadGameState();
            if (loaded) {
                console.log('Game state restored from localStorage');
            }
        });
    </script>
</body>
</html>